## 抽象层次的合理性评估

基于对代码架构的深入分析，我发现了以下抽象层次问题：

### 1. 抽象层次混乱

**问题**：parse 目录和 query 目录的抽象层次不清晰，存在职责交叉。

**具体表现**：
- **parse/ParserQueryService** 应该专注于解析，但实际上承担了大量查询逻辑
- **query/TreeSitterQueryFacade** 作为门面，却包含了具体的查询实现
- 两个目录都试图成为"主导者"，导致层次边界模糊

### 2. 不必要的中间层

**问题**：存在过多的抽象层，增加了系统复杂性。

**冗余层次**：
```
API调用 → ParserFacade → ParserQueryService → TreeSitterQueryFacade → TreeSitterQueryEngine
```

**分析**：
- `ParserFacade` 和 `TreeSitterQueryFacade` 都是门面模式，但功能重叠
- `ParserQueryService` 和 `TreeSitterQueryEngine` 都执行查询，但职责不清

### 3. 抽象层次倒置

**问题**：低层组件依赖高层组件，违反了依赖倒置原则。

**具体例子**：
```typescript
// DynamicParserManager.ts (parse层) 依赖 TreeSitterQueryFacade (query层)
import { TreeSitterQueryFacade } from '../query/TreeSitterQueryFacade';

// TreeSitterQueryExecutor.ts (query层) 又需要 DynamicParserManager
const { DynamicParserManager } = await import('../parse/DynamicParserManager');
```

### 4. 职责抽象不当

**parse 目录的抽象问题**：
- 应该专注于"解析"职责，但包含了查询、缓存、性能监控等多种职责
- `ParserQueryService` 名称暗示它是查询服务，但放在 parse 目录中

**query 目录的抽象问题**：
- 包含了从低层查询执行到高层配置管理的所有内容
- 缺乏清晰的分层，查询执行、缓存、配置混在一起

### 5. 接口抽象不一致

**问题**：相似功能使用不同的接口抽象。

**例子**：
- 实体查询：ParserQueryService 使用字符串类型，TreeSitterQueryFacade 使用枚举类型
- 缓存接口：两个目录使用完全不同的缓存键生成策略

现在让我分析依赖关系和耦合度。