# C++ 现代特性 Tree-Sitter查询规则测试用例
本文档为C++现代特性的Tree-Sitter查询规则提供测试用例，每个查询规则后都附有相应的测试代码示例，方便在TreeSitter Playground中进行验证。
## 1. 显式特化 (Explicit Specializations)
### 查询规则
```
(explicit_specialization) @definition.explicit_specialization
```
### 测试用例
```cpp
#include <iostream>
#include <vector>
template<typename T>
class MyContainer {
public:
    void print() {
        std::cout << "Generic container\n";
    }
};
// 显式特化
template<>
class MyContainer<int> {
public:
    void print() {
        std::cout << "Specialized container for int\n";
    }
};
// 显式特化函数
template<typename T>
void func(T value) {
    std::cout << "Generic function: " << value << std::endl;
}
template<>
void func<int>(int value) {
    std::cout << "Specialized function for int: " << value << std::endl;
}
int main() {
    MyContainer<double> generic;
    MyContainer<int> specialized;
    
    generic.print();
    specialized.print();
    
    func(42.5);
    func(42);
    
    return 0;
}
```
## 2. 静态断言 (Static Assert)
### 查询规则
```
(static_assert_declaration) @definition.static_assert
```
### 测试用例
```cpp
#include <type_traits>
template<typename T>
class SafeContainer {
    static_assert(std::is_copy_constructible<T>::value, 
                  "Type T must be copy constructible");
    static_assert(sizeof(T) >= 4, 
                  "Type T must be at least 4 bytes");
    
public:
    T data;
    SafeContainer(T val) : data(val) {}
};
// 静态断言在命名空间级别
static_assert(sizeof(int) == 4, "int must be 4 bytes");
static_assert(__cplusplus >= 201103L, "C++11 or later required");
int main() {
    SafeContainer<double> container(42.0);
    return 0;
}
```
## 3. 属性声明 (Attribute Declarations)
### 查询规则
```
(attribute_declaration) @definition.attribute_declaration
(attribute_specifier) @definition.attribute_specifier
```
### 测试用例
```cpp
#include <cstdio>
// 函数属性
[[nodiscard]] int get_value() {
    return 42;
}
[[deprecated("Use new_function instead")]] 
void old_function() {
    printf("This function is deprecated\n");
}
// [[likely]] and [[unlikely]] (C++20)
int process_value(int x) {
    if (x < 0) [[unlikely]] {
        return -1;
    }
    
    return x * 2;
}
// 类属性
class [[gnu::aligned(16)]] AlignedClass {
public:
    int data[4];
};
// 变量属性
void function_example() {
    [[maybe_unused]] int unused_var = 0;
    [[fallthrough]] int x = 10;
    
    switch(x) {
        case 10:
            printf("Case 10\n");
            [[fallthrough]];
        case 20:
            printf("Case 10 or 20\n");
            break;
    }
}
// 命名空间属性
namespace [[deprecated]] OldNamespace {
    void old_func() {}
}
```
## 4. Requires 子句 (C++20 Concepts)
### 查询规则
```
(requires_clause) @definition.requires_clause
```
### 测试用例
```cpp
#include <concepts>
#include <iostream>
// 简单概念
template<typename T>
concept Printable = requires(T t) {
    std::cout << t;
};
// 使用requires子句的函数模板
template<typename T>
requires Printable<T> && std::default_constructible<T>
T create_and_print() {
    T obj{};
    std::cout << obj;
    return obj;
}
// 在类模板中使用requires子句
template<typename T>
class Container requires std::copyable<T> {
public:
    T value;
    Container(T v) : value(v) {}
};
// 复杂的requires表达式
template<typename T, typename U>
requires requires(T t, U u) {
    t + u;  // 检查是否可以执行 t + u
    { t + u } -> std::convertible_to<int>;  // 检查结果是否可转换为int
}
auto add(T t, U u) {
    return t + u;
}
// requires子句与类型约束
template<typename T>
requires std::integral<T> || std::floating_point<T>
void process_number(T value) {
    std::cout << "Processing number: " << value << std::endl;
}
int main() {
    create_and_print<int>();
    Container<double> c(42.0);
    add(10, 20);
    process_number(42);
    process_number(3.14);
    
    return 0;
}
```
## 5. 对齐说明符 (Alignment Specifiers)
### 查询规则
```
(alignas_specifier) @definition.alignas_specifier
```
### 测试用例
```cpp
#include <iostream>
#include <new>
// 使用alignas指定对齐方式
alignas(16) struct AlignedPoint {
    float x, y, z;
};
// 对齐到特定类型的对齐要求
alignas(double) char buffer[100];
// 在类中使用对齐说明符
class AlignedClass {
public:
    alignas(32) int data[8];
    char padding;  // 这个成员不会影响对齐
};
// 函数参数对齐
void aligned_function(alignas(64) int arr[10]) {
    // 函数体
}
// 变量对齐
void example() {
    alignas(128) char large_buffer[1024];
    alignas(std::max_align_t) char max_aligned_buffer[256];
    
    std::cout << "AlignedPoint alignment: " << alignof(AlignedPoint) << std::endl;
    std::cout << "Large buffer address: " << reinterpret_cast<void*>(large_buffer) << std::endl;
}
int main() {
    AlignedPoint p = {1.0f, 2.0f, 3.0f};
    example();
    
    return 0;
}
```
## 6. 用户定义字面量 (User-Defined Literals)
### 查询规则
```
(literal_suffix) @definition.literal_suffix
```
### 测试用例
```cpp
#include <chrono>
#include <string>
#include <complex>
#include <iostream>
// 定义用户字面量后缀 - 时间
std::chrono::seconds operator"" _s(unsigned long long seconds) {
    return std::chrono::seconds(seconds);
}
std::chrono::milliseconds operator"" _ms(unsigned long long ms) {
    return std::chrono::milliseconds(ms);
}
// 定义用户字面量后缀 - 长度
long double operator"" _km(long double km) {
    return km * 100.0;  // 转换为米
}
long double operator"" _m(long double m) {
    return m;  // 保持米
}
// 定义用户字面量后缀 - 字符串处理
std::string operator"" _str(const char* str, std::size_t len) {
    return std::string(str, len);
}
// 定义用户字面量后缀 - 复数
std::complex<double> operator"" _i(long double d) {
    return std::complex<double>(0, d);
}
// 定义用户字面量后缀 - 自定义类型
class Distance {
public:
    double meters;
    Distance(double m) : meters(m) {}
};
Distance operator"" _ft(long double feet) {
    return Distance(feet * 0.3048);  // 转换为米
}
int main() {
    // 使用时间字面量
    auto duration = 5_s + 1000_ms;
    std::cout << "Duration: " << duration.count() << "ms\n";
    
    // 使用长度字面量
    auto distance = 5.0_km + 3.2_m;
    std::cout << "Distance: " << distance << " meters\n";
    
    // 使用字符串字面量
    auto text = "Hello World"_str;
    std::cout << "Text: " << text << std::endl;
    
    // 使用复数字面量
    auto complex_num = 3.0 + 4.0_i;
    std::cout << "Complex: " << complex_num << std::endl;
    
    // 使用距离字面量
    auto height = 6.0_ft;
    std::cout << "Height in meters: " << height.meters << std::endl;
    
    return 0;
}