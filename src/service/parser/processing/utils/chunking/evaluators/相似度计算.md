基于搜索结果和我的分析，我来回答您的问题：

## 关于相似度计算方法的建议

### 1. 是否应当保留基于关键词匹配的相似度计算？

**建议：保留，但作为多种方法之一**

原因：
- **互补性**：关键词匹配（Jaccard相似度）和编辑距离（Levenshtein）各有优势
  - 关键词匹配：快速、适合词汇重叠度高的文本
  - 编辑距离：更精确，能捕捉字符级别的差异
- **性能考虑**：关键词匹配计算成本更低，适合快速预筛选
- **不同场景适用性**：
  - 代码片段：编辑距离更准确
  - 文档/注释：关键词匹配可能更合适

### 2. 代码/文本块相似度计算的其他方法

根据搜索结果，以下是可用的方法：

#### A. 传统文本相似度方法
1. **TF-IDF + 余弦相似度**
   - 适合文档级别比较
   - 考虑词频和逆文档频率

2. **Jaccard相似度**
   - 基于词汇集合的交集/并集
   - 计算简单，但不考虑语义

3. **余弦相似度**
   - 向量空间模型
   - 适合高维向量比较

#### B. 基于嵌入的方法
1. **Word2Vec/Doc2Vec**
   - 将词/文档转换为向量
   - 能捕捉语义关系

2. **Sentence Transformers**
   - 专门为句子相似度设计
   - 预训练模型，开箱即用

3. **BERT等Transformer模型**
   - 深度语义理解
   - 上下文感知

#### C. 代码特定的相似度方法
1. **AST（抽象语法树）编辑距离**
   - 考虑代码结构而非纯文本
   - 对格式变化不敏感

2. **Token序列相似度**
   - 基于词法分析后的token
   - 忽略空白和注释

3. **程序依赖图（PDG）相似度**
   - 考虑数据和控制流
   - 适合功能相似性检测

### 3. 推荐的混合策略

```typescript
interface SimilarityStrategy {
  name: string;
  weight: number;
  calculate: (content1: string, content2: string) => number;
}

class HybridSimilarityCalculator {
  private strategies: SimilarityStrategy[] = [
    {
      name: 'levenshtein',
      weight: 0.4,
      calculate: SimilarityUtils.calculateSimilarity
    },
    {
      name: 'keyword',
      weight: 0.3,
      calculate: this.calculateKeywordSimilarity
    },
    {
      name: 'semantic',
      weight: 0.3,
      calculate: this.calculateSemanticSimilarity // 可选：使用嵌入模型
    }
  ];
  
  calculateSimilarity(content1: string, content2: string): number {
    return this.strategies.reduce((total, strategy) => {
      return total + strategy.weight * strategy.calculate(content1, content2);
    }, 0);
  }
}
```

### 4. 实施建议

1. **短期方案**：
   - 保留现有的 Levenshtein 距离（SimilarityUtils）
   - 添加关键词匹配作为补充
   - 使用加权组合

2. **中期方案**：
   - 集成轻量级嵌入模型（如 Sentence Transformers）
   - 根据内容类型选择不同策略

3. **长期方案**：
   - 实现AST级别的代码相似度
   - 添加机器学习模型进行智能权重调整

这样的设计既保持了灵活性，又能根据不同场景选择最适合的相似度计算方法。