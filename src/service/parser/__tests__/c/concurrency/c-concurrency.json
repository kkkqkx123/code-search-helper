{
  "requests": [
    {
      "language": "c",
      "code": "#include <pthread.h>\n#include <windows.h>\n\nvoid* thread_function(void* arg) {\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    pthread_attr_t attr;\n    \n    // pthread_create测试\n    pthread_create(&thread, &attr, thread_function, NULL);\n    \n    // CreateThread测试\n    HANDLE hThread = CreateThread(\n        NULL,                   // Security attributes\n        0,                      // Stack size\n        (LPTHREAD_START_ROUTINE)thread_function,  // Start function\n        NULL,                   // Argument\n        0,                      // Creation flags\n        NULL                    // Thread ID\n    );\n    \n    // _beginthreadex测试\n    HANDLE hThread2 = (HANDLE)_beginthreadex(\n        NULL,                   // Security\n        0,                      // Stack size\n        (LPTHREAD_START_ROUTINE)thread_function,  // Start function\n        NULL,                   // Argument\n        0,                      // Init flag\n        NULL                    // Thread address\n    );\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.thread.creation\n  function: (identifier) @thread.create.function\n  (#match? @thread.create.function \"^(pthread_create|CreateThread|_beginthreadex)$\")\n  arguments: (argument_list\n    (identifier) @thread.handle\n    (identifier) @thread.attributes\n    (identifier) @thread.start.function\n    (identifier) @thread.argument)"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    \n    pthread_mutex_init(&mutex, NULL);\n    pthread_mutex_lock(&mutex);\n    pthread_mutex_unlock(&mutex);\n    \n    // pthread_mutex_destroy测试\n    pthread_mutex_destroy(&mutex);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.mutex.operation\n  function: (identifier) @mutex.operation.function\n  (#match? @mutex.operation.function \"^(pthread_mutex_destroy)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle))"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_cond_t cond;\n    pthread_condattr_t attr;\n    \n    // pthread_cond_init测试\n    pthread_cond_init(&cond, &attr);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.condition.operation\n  function: (identifier) @cond.operation.function\n  (#match? @cond.operation.function \"^(pthread_cond_init)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle)\n    (identifier)? @cond.attributes)"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n#include <time.h>\n\nint main() {\n    pthread_cond_t cond;\n    pthread_mutex_t mutex;\n    \n    pthread_cond_init(&cond, NULL);\n    pthread_mutex_init(&mutex, NULL);\n    \n    pthread_mutex_lock(&mutex);\n    \n    // pthread_cond_wait测试\n    pthread_cond_wait(&cond, &mutex);\n    \n    // pthread_cond_timedwait测试\n    struct timespec timeout;\n    clock_gettime(CLOCK_REALTIME, &timeout);\n    timeout.tv_sec += 5; // 5秒后超时\n    pthread_cond_timedwait(&cond, &mutex, &timeout);\n    \n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.condition.operation\n  function: (identifier) @cond.operation.function\n  (#match? @cond.operation.function \"^(pthread_cond_wait|pthread_cond_timedwait)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle)\n    (pointer_expression argument: (identifier) @mutex.handle))"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_cond_t cond;\n    pthread_mutex_t mutex;\n    \n    pthread_cond_init(&cond, NULL);\n    pthread_mutex_init(&mutex, NULL);\n    \n    pthread_mutex_lock(&mutex);\n    \n    // pthread_cond_signal测试\n    pthread_cond_signal(&cond);\n    \n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.condition.operation\n  function: (identifier) @cond.operation.function\n  (#match? @cond.operation.function \"^(pthread_cond_signal)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle))"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_cond_t cond;\n    pthread_mutex_t mutex;\n    \n    pthread_cond_init(&cond, NULL);\n    pthread_mutex_init(&mutex, NULL);\n    \n    pthread_mutex_lock(&mutex);\n    \n    // pthread_cond_broadcast测试\n    pthread_cond_broadcast(&cond);\n    \n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.condition.operation\n  function: (identifier) @cond.operation.function\n  (#match? @cond.operation.function \"^(pthread_cond_broadcast)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle))"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_cond_t cond;\n    \n    pthread_cond_init(&cond, NULL);\n    \n    // pthread_cond_destroy测试\n    pthread_cond_destroy(&cond);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.condition.operation\n  function: (identifier) @cond.operation.function\n  (#match? @cond.operation.function \"^(pthread_cond_destroy)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle))"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    pthread_rwlockattr_t attr;\n    \n    // pthread_rwlock_init测试\n    pthread_rwlock_init(&rwlock, &attr);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.rwlock.operation\n  function: (identifier) @rwlock.operation.function\n  (#match? @rwlock.operation.function \"^(pthread_rwlock_init)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle)\n    (identifier)? @rwlock.attributes)"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    \n    pthread_rwlock_init(&rwlock, NULL);\n    \n    // pthread_rwlock_rdlock测试\n    pthread_rwlock_rdlock(&rwlock);\n    \n    // Read-only section\n    // ...\n    \n    pthread_rwlock_unlock(&rwlock);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.rwlock.operation\n  function: (identifier) @rwlock.operation.function\n  (#match? @rwlock.operation.function \"^(pthread_rwlock_rdlock)$\")\n arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle))"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    \n    pthread_rwlock_init(&rwlock, NULL);\n    \n    // pthread_rwlock_wrlock测试\n    pthread_rwlock_wrlock(&rwlock);\n    \n    // Write section\n    // ...\n    \n    pthread_rwlock_unlock(&rwlock);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.rwlock.operation\n  function: (identifier) @rwlock.operation.function\n  (#match? @rwlock.operation.function \"^(pthread_rwlock_wrlock)$\")\n arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle))"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    \n    pthread_rwlock_init(&rwlock, NULL);\n    pthread_rwlock_wrlock(&rwlock);\n    \n    // Write section\n    // ...\n    \n    // pthread_rwlock_unlock测试\n    pthread_rwlock_unlock(&rwlock);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.rwlock.operation\n  function: (identifier) @rwlock.operation.function\n  (#match? @rwlock.operation.function \"^(pthread_rwlock_unlock)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle))"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nvoid* thread_function(void* arg) {\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    void* result;\n    \n    pthread_create(&thread, NULL, thread_function, NULL);\n    \n    // pthread_join测试\n    pthread_join(thread, &result);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.thread.wait\n  function: (identifier) @thread.wait.function\n  (#match? @thread.wait.function \"^(pthread_join)$\")\n  arguments: (argument_list\n    (identifier) @thread.handle\n    (identifier)? @thread.return.value)"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    \n    pthread_rwlock_init(&rwlock, NULL);\n    pthread_rwlock_wrlock(&rwlock);\n    pthread_rwlock_unlock(&rwlock);\n    \n    // pthread_rwlock_destroy测试\n    pthread_rwlock_destroy(&rwlock);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.rwlock.operation\n  function: (identifier) @rwlock.operation.function\n  (#match? @rwlock.operation.function \"^(pthread_rwlock_destroy)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle))"
    },
    {
      "language": "c",
      "code": "#include <semaphore.h>\n\nint main() {\n    sem_t sem;\n    \n    // sem_init测试\n    sem_init(&sem, 0, 1); // 初始化为1，表示可用资源数\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.semaphore.operation\n function: (identifier) @semaphore.operation.function\n  (#match? @semaphore.operation.function \"^(sem_init)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle)\n    (identifier) @semaphore.pshared\n    (identifier) @semaphore.value)"
    },
    {
      "language": "c",
      "code": "#include <semaphore.h>\n\nint main() {\n    sem_t sem;\n    \n    sem_init(&sem, 0, 1);\n    \n    // sem_wait测试\n    sem_wait(&sem);\n    \n    // Critical section\n    // ...\n    \n    sem_post(&sem);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.semaphore.operation\n  function: (identifier) @semaphore.wait.function\n  (#match? @semaphore.wait.function \"^(sem_wait)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle))"
    },
    {
      "language": "c",
      "code": "#include <semaphore.h>\n#include <stdio.h>\n\nint main() {\n    sem_t sem;\n    \n    sem_init(&sem, 0, 1);\n    \n    // sem_trywait测试\n    int result = sem_trywait(&sem);\n    if (result == 0) {\n        // Critical section\n        // ...\n        sem_post(&sem);\n    } else {\n        printf(\"Semaphore not available\\n\");\n    }\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.semaphore.operation\n  function: (identifier) @semaphore.trywait.function\n  (#match? @semaphore.trywait.function \"^(sem_trywait)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle))"
    },
    {
      "language": "c",
      "code": "#include <semaphore.h>\n\nint main() {\n    sem_t sem;\n    \n    sem_init(&sem, 0, 0);\n    sem_wait(&sem);\n    \n    // Critical section\n    // ...\n    \n    // sem_post测试\n    sem_post(&sem);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.semaphore.operation\n  function: (identifier) @semaphore.post.function\n  (#match? @semaphore.post.function \"^(sem_post)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle))"
    },
    {
      "language": "c",
      "code": "#include <semaphore.h>\n\nint main() {\n    sem_t sem;\n    \n    sem_init(&sem, 0, 1);\n    sem_wait(&sem);\n    sem_post(&sem);\n    \n    // sem_destroy测试\n    sem_destroy(&sem);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.semaphore.operation\n  function: (identifier) @semaphore.destroy.function\n  (#match? @semaphore.destroy.function \"^(sem_destroy)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle))"
    },
    {
      "language": "c",
      "code": "#include <stdatomic.h>\n\nint main() {\n    // atomic_thread_fence测试\n    atomic_thread_fence(memory_order_seq_cst);\n    \n    // __atomic_thread_fence测试\n    __atomic_thread_fence(__ATOMIC_SEQ_CST);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.barrier.operation\n function: (identifier) @barrier.operation.function\n  (#match? @barrier.operation.function \"^(atomic_thread_fence|__atomic_thread_fence)$\")\n  arguments: (argument_list\n    (identifier)? @memory.order)"
    },
    {
      "language": "c",
      "code": "int main() {\n    // __sync_synchronize测试\n    __sync_synchronize();\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.barrier.operation\n  function: (identifier) @barrier.operation.function\n  (#match? @barrier.operation.function \"^(__sync_synchronize)$\")\n  arguments: (argument_list)"
    },
    {
      "language": "c",
      "code": "// __thread测试\n__thread int thread_local_var1;\n\n// _Thread_local测试\n_Thread_local int thread_local_var2;\n\n// 线程本地存储的完整声明\n__thread static int counter = 0;\n\nint main() {\n    // 使用线程本地变量\n    thread_local_var1 = 42;\n    thread_local_var2 = 24;\n    counter++;\n    \n    return 0;\n}",
      "query": "(declaration\n  (storage_class_specifier) @thread.local.specifier\n  (#match? @thread.local.specifier \"^(__thread|_Thread_local)$\")\n  type: (primitive_type) @thread.local.type\n  declarator: (identifier) @thread.local.variable) @concurrency.relationship.thread.local"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nvoid* thread_function(void* arg) {\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    \n    pthread_create(&thread, NULL, thread_function, NULL);\n    \n    // pthread_detach测试\n    pthread_detach(thread);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.thread.detach\n  function: (identifier) @thread.detach.function\n  (#match? @thread.detach.function \"^(pthread_detach)$\")\n  arguments: (argument_list\n    (identifier) @thread.handle)"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nvoid* thread_function(void* arg) {\n    // pthread_exit测试\n    pthread_exit(NULL);\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    \n    pthread_create(&thread, NULL, thread_function, NULL);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.thread.exit\n  function: (identifier) @thread.exit.function\n  (#match? @thread.exit.function \"^(pthread_exit)$\")\n  arguments: (argument_list\n    (identifier)? @thread.exit.value)"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n#include <stdio.h>\n\nvoid* thread_function(void* arg) {\n    // pthread_self测试\n    pthread_t tid = pthread_self();\n    printf(\"Thread ID: %lu\\n\", tid);\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    \n    pthread_create(&thread, NULL, thread_function, NULL);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.thread.id\n  function: (identifier) @thread.id.function\n  (#match? @thread.id.function \"^(pthread_self)$\")\n  arguments: (argument_list)"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    pthread_mutexattr_t attr;\n    \n    // pthread_mutex_init测试\n    pthread_mutex_init(&mutex, &attr);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.mutex.operation\n  function: (identifier) @mutex.operation.function\n  (#match? @mutex.operation.function \"^(pthread_mutex_init)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle)\n    (identifier)? @mutex.attributes)"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    \n    pthread_mutex_init(&mutex, NULL);\n    \n    // pthread_mutex_lock测试\n    pthread_mutex_lock(&mutex);\n    \n    // Critical section\n    // ...\n    \n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.mutex.operation\n  function: (identifier) @mutex.lock.function\n  (#match? @mutex.lock.function \"^(pthread_mutex_lock)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle))"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n#include <stdio.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    \n    pthread_mutex_init(&mutex, NULL);\n    \n    // pthread_mutex_trylock测试\n    int result = pthread_mutex_trylock(&mutex);\n    if (result == 0) {\n        // Critical section\n        // ...\n        pthread_mutex_unlock(&mutex);\n    } else {\n        printf(\"Mutex is locked by another thread\\n\");\n    }\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.mutex.operation\n  function: (identifier) @mutex.trylock.function\n  (#match? @mutex.trylock.function \"^(pthread_mutex_trylock)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle))"
    },
    {
      "language": "c",
      "code": "#include <pthread.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    \n    pthread_mutex_init(&mutex, NULL);\n    pthread_mutex_lock(&mutex);\n    \n    // Critical section\n    // ...\n    \n    // pthread_mutex_unlock测试\n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
      "query": "(call_expression) @concurrency.relationship.mutex.operation\n  function: (identifier) @mutex.unlock.function\n  (#match? @mutex.unlock.function \"^(pthread_mutex_unlock)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle))"
    }
  ]
}