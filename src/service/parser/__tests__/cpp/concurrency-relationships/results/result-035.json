{
  "testId": "concurrency-relationships-035",
  "request": {
    "language": "cpp",
    "code": "#include <coroutine>\n#include <iostream>\n\nstruct Awaiter {\n    bool await_ready() { return false; }\n    void await_suspend(std::coroutine_handle<>) {\n        std::cout << \"Coroutine suspended\" << std::endl;\n    }\n    void await_resume() {\n        std::cout << \"Coroutine resumed\" << std::endl;\n    }\n};\n\nstruct Task {\n    struct promise_type {\n        Task get_return_object() {\n            return Task{std::coroutine_handle<promise_type>::from_promise(*this)};\n        }\n        std::suspend_never initial_suspend() { return {}; }\n        std::suspend_never final_suspend() noexcept { return {}; }\n        void return_void() {}\n        void unhandled_exception() {}\n    };\n    \n    std::coroutine_handle<promise_type> h;\n    Task(std::coroutine_handle<promise_type> handle) : h(handle) {}\n    ~Task() { if (h) h.destroy(); }\n};\n\nTask coroutineWithAwait() {\n    std::cout << \"Before await\" << std::endl;\n    co_await Awaiter{};\n    std::cout << \"After await\" << std::endl;\n}\n\nint main() {\n    auto task = coroutineWithAwait();\n    return 0;\n}",
    "queries": [
      "(await_expression\n (call_expression) @awaited.call) @concurrency.relationship.coroutine.await"
    ]
  },
  "response": {
    "success": true,
    "data": [],
    "errors": [],
    "timestamp": "2025-11-21T08:47:11.038Z"
  },
  "timestamp": "2025-11-21T08:47:11.038Z"
}