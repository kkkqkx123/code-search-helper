{"cells":[{"code":"#include <queue>\r\n#include <mutex>\r\n#include <condition_variable>\r\n#include <thread>\r\n#include <iostream>\r\n\r\ntemplate<typename T>\r\nclass ProducerConsumerQueue {\r\nprivate:\r\n    std::queue<T> queue;\r\n    std::mutex mtx;\r\n    std::condition_variable cv;\r\n    \r\npublic:\r\n    void push(const T& item) {\r\n        std::lock_guard<std::mutex> lock(mtx);\r\n        queue.push(item);\r\n        cv.notify_one();\r\n    }\r\n    \r\n    T pop() {\r\n        std::unique_lock<std::mutex> lock(mtx);\r\n        cv.wait(lock, [this]{ return !queue.empty(); });\r\n        T item = queue.front();\r\n        queue.pop();\r\n        return item;\r\n    }\r\n};\r\n\r\nint main() {\r\n    ProducerConsumerQueue<int> pcQueue;\r\n    \r\n    auto producer = [&]() {\r\n        for (int i = 0; i < 5; ++i) {\r\n            pcQueue.push(i);\r\n            std::cout << \"Produced: \" << i << std::endl;\r\n        }\r\n    };\r\n    \r\n    auto consumer = [&]() {\r\n        for (int i = 0; i < 5; ++i) {\r\n            int item = pcQueue.pop();\r\n            std::cout << \"Consumed: \" << item << std::endl;\r\n        }\r\n    };\r\n    \r\n    std::thread t1(producer);\r\n    std::thread t2(consumer);\r\n    \r\n    t1.join();\r\n    t2.join();\r\n    \r\n    return 0;\r\n}","language":"cpp","kind":"code"},{"code":"(class_specifier\r\n  name: (type_identifier) @producer.consumer.class\r\n body: (field_declaration_list\r\n    (field_declaration\r\n      declarator: (field_declarator\r\n        declarator: (field_identifier) @queue.field))\r\n    (field_declaration\r\n      declarator: (field_declarator\r\n        declarator: (field_identifier) @mutex.field))\r\n    (field_declaration\r\n      declarator: (field_declarator\r\n        declarator: (field_identifier) @condition.field)))) @concurrency.relationship.producer.consumer","language":"scm","kind":"code"}]}