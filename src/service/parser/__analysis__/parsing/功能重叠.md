
## 两个目录之间的功能重叠分析

通过深入分析代码，我发现了以下几个关键的功能重叠问题：

### 1. 查询执行功能重叠

**严重重叠**：
- **parse/ParserQueryService.ts** 和 **query/TreeSitterQueryFacade.ts** 都提供了相同的查询方法：
  - `findFunctions()`, `findTypes()`, `findVariables()`, `findClasses()`
  - `findCallRelationships()`, `findDependencies()`, `findInheritance()`

**具体重叠代码**：
```typescript
// ParserQueryService.ts 第 151-153 行
async findFunctions(ast: Parser.SyntaxNode, language: string): Promise<EntityQueryResult[]> {
  return this.executeEntityQuery(ast, language, 'functions', QueryPriority.MEDIUM)
}

// TreeSitterQueryFacade.ts 第 182-184 行
static async findFunctions(ast: Parser.SyntaxNode, language: string): Promise<EntityQueryResult[]> {
  return this.executeEntityQuery(ast, EntityType.FUNCTION, language);
}
```

### 2. 缓存管理功能重叠

**中度重叠**：
- **parse/ParserCacheService.ts** 和 **query/QueryCache.ts** 都提供缓存功能
- 两者都缓存查询结果，但使用不同的缓存键和策略

**重叠问题**：
- ParserCacheService: `generateQueryCacheKey(language, queryType, nodeHash)`
- QueryCache: `forEntityQuery(ast, entityType, language)`

### 3. 查询系统初始化重叠

**中度重叠**：
- **parse/DynamicParserManager.ts** 和 **query/QueryRegistry.ts** 都负责查询系统的初始化
- 两者都有 `initializeQuerySystem()` 方法

### 4. 性能监控重叠

**轻度重叠**：
- **parse/ParserQueryService.ts** 和 **query/QueryPerformanceMonitor.ts** 都收集性能统计
- 两者都跟踪查询执行时间和缓存命中率

### 5. 语言检测功能重叠

**轻度重叠**：
- **parse/DynamicParserManager.ts** 和 **query/TreeSitterQueryExecutor.ts** 都有语言检测逻辑

现在让我评估抽象层次的合理性。