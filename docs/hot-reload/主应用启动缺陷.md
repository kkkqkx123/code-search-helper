现在让我确认问题诊断并提出修复方案：

## 问题诊断确认

基于我的分析，我确认了两个最可能的问题源：

### 1. 主应用程序启动逻辑缺陷（主要问题）
**位置**：[`src/main.ts:210`](src/main.ts:210)
```typescript
const projectPath = process.cwd();
```

**问题**：
- 系统使用 `process.cwd()`（当前工作目录）作为项目路径
- 这导致无论用户映射了哪些项目，系统总是自动索引启动服务的目录
- 没有检查该路径是否在项目映射中
- 没有考虑用户可能只想索引特定项目而非当前工作目录

### 2. 热更新初始化范围错误（次要问题）
**位置**：[`src/main.ts:204-239`](src/main.ts:204-239)

**问题**：
- 热更新初始化逻辑只处理当前工作目录
- 没有遍历所有已映射的项目来启用热更新
- 缺乏对项目映射中有效项目的检查机制

## 修复方案

### 方案 1：修改主应用程序启动逻辑（推荐）

**核心思路**：
1. 不再自动索引当前工作目录
2. 只为项目映射中已存在的项目启用热更新
3. 提供配置选项控制是否自动索引未映射的目录

**具体修改**：

1. **修改 [`src/main.ts`](src/main.ts:204-239) 中的热更新初始化逻辑**：

```typescript
// Check if hot reload is enabled via configuration
const hotReloadEnabled = this.configService.get('hotReload.enabled', true);
if (hotReloadEnabled) {
  try {
    await this.loggerService.info('Initializing hot reload for mapped projects...');
    
    // 获取所有已映射的项目路径
    const mappedProjectPaths = this.projectIdManager.listAllProjectPaths();
    
    if (mappedProjectPaths.length === 0) {
      await this.loggerService.info('No mapped projects found, hot reload will not be enabled for any project');
      
      // 可选：如果配置允许，可以自动索引当前工作目录
      const autoIndexCurrentDir = this.configService.get('hotReload.autoIndexCurrentDir', false);
      if (autoIndexCurrentDir) {
        const currentDir = process.cwd();
        await this.loggerService.info(`Auto-indexing current directory as configured: ${currentDir}`);
        await this.indexService.startIndexing(currentDir, { enableHotReload: true });
      }
    } else {
      // 为每个已映射的项目启用热更新
      for (const projectPath of mappedProjectPaths) {
        try {
          // 检查项目路径是否存在
          const projectExists = await this.checkProjectPathExists(projectPath);
          if (!projectExists) {
            await this.loggerService.warn(`Project path does not exist, skipping: ${projectPath}`);
            continue;
          }

          // 检查项目是否已索引
          const projectId = this.projectIdManager.getProjectId(projectPath);
          if (!projectId) {
            await this.loggerService.info(`Project not indexed, starting indexing process: ${projectPath}`);
            await this.indexService.startIndexing(projectPath, { enableHotReload: true });
          } else {
            await this.loggerService.info(`Project already indexed, enabling hot reload: ${projectPath}`);
            await this.indexService.startProjectWatching(projectPath);
          }
        } catch (projectError) {
          await this.loggerService.error(`Failed to initialize hot reload for project ${projectPath}:`, projectError);
          // 继续处理其他项目
        }
      }
    }
    
    await this.loggerService.info('Hot reload initialization completed');
  } catch (error) {
    await this.loggerService.error('Failed to initialize hot reload services:', error);
    // Graceful degradation - continue without hot reload
    await this.loggerService.warn('Hot reload disabled due to initialization error');
  }
} else {
  await this.loggerService.info('Hot reload is disabled via configuration');
}
```

2. **添加项目路径存在性检查方法**：

```typescript
/**
 * 检查项目路径是否存在
 */
private async checkProjectPathExists(projectPath: string): Promise<boolean> {
  try {
    const fs = await import('fs/promises');
    await fs.access(projectPath);
    return true;
  } catch {
    return false;
  }
}
```

### 方案 2：增强 ChangeDetectionService 的项目验证（补充）

**核心思路**：
- 在 ChangeDetectionService 中添加项目验证逻辑
- 确保只监控已映射的项目路径

**具体修改**：

1. **修改 [`src/service/filesystem/ChangeDetectionService.ts`](src/service/filesystem/ChangeDetectionService.ts:138-148)**：

```typescript
async initialize(rootPaths: string[], watcherOptions?: FileWatcherOptions): Promise<void> {
  if (this.isRunning) {
    this.logger.warn('ChangeDetectionService is already initialized');
    return;
  }

  try {
    this.logger.info('Initializing ChangeDetectionService', { rootPaths, options: this.options });

    // 验证根路径是否为有效的项目路径
    const validRootPaths = await this.validateRootPaths(rootPaths);
    
    if (validRootPaths.length === 0) {
      this.logger.warn('No valid project paths found, ChangeDetectionService will not be initialized');
      return;
    }

    // Initialize file hashes for existing files
    await this.initializeFileHashes(validRootPaths);
    // ... 其余逻辑保持不变
  } catch (error) {
    // ... 错误处理逻辑
  }
}

/**
 * 验证根路径是否为有效的项目路径
 */
private async validateRootPaths(rootPaths: string[]): Promise<string[]> {
  const validPaths: string[] = [];
  
  for (const path of rootPaths) {
    try {
      // 检查路径是否存在
      const fs = await import('fs/promises');
      await fs.access(path);
      
      // 检查路径是否在项目映射中（如果有 ProjectIdManager 引用）
      // 这里可以添加与 ProjectIdManager 的集成逻辑
      
      validPaths.push(path);
    } catch (error) {
      this.logger.warn(`Invalid project path, skipping: ${path}`, error);
    }
  }
  
  return validPaths;
}
```

### 方案 3：改进 ProjectHotReloadService 的路径匹配（补充）

**核心思路**：
- 改进路径匹配逻辑，使用规范化路径比较
- 增强路径匹配的准确性

**具体修改**：

1. **修改 [`src/service/filesystem/ProjectHotReloadService.ts`](src/service/filesystem/ProjectHotReloadService.ts:132-142)**：

```typescript
private getProjectPathFromEvent(event: FileChangeEvent): string | null {
  // 使用规范化路径进行匹配
  const eventPath = HashUtils.normalizePath(event.path);
  const possibleProjectPaths = Array.from(this.projectConfigs.keys());
  
  // 按路径长度降序排序，确保最长的路径优先匹配
  // 这可以避免子路径被父路径错误匹配
  const sortedPaths = possibleProjectPaths
    .map(path => HashUtils.normalizePath(path))
    .sort((a, b) => b.length - a.length);
  
  for (const projectPath of sortedPaths) {
    // 确保路径分隔符一致，避免部分匹配
    const normalizedProjectPath = projectPath.endsWith(path.sep) ? projectPath : projectPath + path.sep;
    
    if (eventPath.startsWith(normalizedProjectPath) || eventPath === projectPath) {
      return projectPath;
    }
  }
  
  return null;
}
```

## 推荐实施方案

我建议按以下顺序实施方案：

1. **首先实施方案 1**：修改主应用程序启动逻辑，这是最关键的问题
2. **然后实施方案 3**：改进 ProjectHotReloadService 的路径匹配，提高准确性
3. **最后实施方案 2**：增强 ChangeDetectionService 的项目验证，作为额外的安全措施

这样的顺序可以确保首先解决最核心的问题，然后逐步完善系统的健壮性。