# åç«¯Graph APIå®Œå–„å®æ–½è®¡åˆ’

## ğŸ“‹ æ¦‚è¿°

æœ¬è®¡åˆ’è¯¦ç»†æè¿°äº†å¦‚ä½•å®Œå–„åç«¯Graph APIç«¯ç‚¹ï¼ŒåŒ…æ‹¬APIè·¯ç”±å®ç°ã€æœåŠ¡å±‚å¼€å‘ã€æ•°æ®è®¿é—®å±‚ä¼˜åŒ–å’Œæµ‹è¯•éªŒè¯ç­‰å„ä¸ªé˜¶æ®µã€‚

## ğŸ¯ å®æ–½ç›®æ ‡

### 1. æ ¸å¿ƒåŠŸèƒ½å®ç°
- å®Œæ•´çš„Graph APIç«¯ç‚¹ä½“ç³»
- é«˜æ€§èƒ½çš„å›¾æ•°æ®æ“ä½œæœåŠ¡
- ä¸°å¯Œçš„å›¾åˆ†æåŠŸèƒ½
- å®Œå–„çš„ç›‘æ§å’Œç»Ÿè®¡èƒ½åŠ›

### 2. æŠ€æœ¯ç›®æ ‡
- é«˜å¯ç”¨æ€§å’Œç¨³å®šæ€§
- è‰¯å¥½çš„æ€§èƒ½è¡¨ç°
- æ¸…æ™°çš„ä»£ç ç»“æ„
- å®Œå–„çš„æµ‹è¯•è¦†ç›–

## ğŸ—ï¸ å®æ–½é˜¶æ®µ

### é˜¶æ®µä¸€ï¼šåŸºç¡€æ¡†æ¶æ­å»ºï¼ˆ1å‘¨ï¼‰

#### 1.1 APIè·¯ç”±å±‚å®ç°
- [ ] åˆ›å»ºGraphRoutesåŸºç¡€æ¡†æ¶
- [ ] å®ç°é¡¹ç›®ç©ºé—´ç®¡ç†API
- [ ] æ·»åŠ é”™è¯¯å¤„ç†å’Œå‚æ•°éªŒè¯
- [ ] é›†æˆåˆ°ä¸»APIæœåŠ¡å™¨

#### 1.2 æœåŠ¡ä¾èµ–é…ç½®
- [ ] é…ç½®NebulaServiceä¾èµ–
- [ ] é…ç½®GraphPersistenceServiceä¾èµ–
- [ ] é…ç½®ProjectLookupServiceä¾èµ–
- [ ] æ›´æ–°DIå®¹å™¨é…ç½®

#### 1.3 åŸºç¡€å·¥å…·ç±»å¼€å‘
- [ ] å®ç°Graph APIè¯·æ±‚éªŒè¯å™¨
- [ ] åˆ›å»ºå“åº”æ ¼å¼åŒ–å·¥å…·
- [ ] å®ç°åˆ†é¡µå’Œè¿‡æ»¤å·¥å…·
- [ ] æ·»åŠ æ—¥å¿—è®°å½•å·¥å…·

### é˜¶æ®µäºŒï¼šæ ¸å¿ƒåŠŸèƒ½å¼€å‘ï¼ˆ2å‘¨ï¼‰

#### 2.1 GraphQueryRouteså®ç°
- [ ] å®ç°è‡ªå®šä¹‰æŸ¥è¯¢ç«¯ç‚¹
- [ ] æ·»åŠ å…³ç³»æŸ¥è¯¢åŠŸèƒ½
- [ ] å®ç°è·¯å¾„æœç´¢æ”¯æŒ
- [ ] æ·»åŠ æŸ¥è¯¢ç¼“å­˜æœºåˆ¶

#### 2.2 GraphAnalysisRouteså®ç°
- [ ] å®ç°ä¾èµ–åˆ†æç«¯ç‚¹
- [ ] æ·»åŠ è°ƒç”¨å›¾åˆ†æåŠŸèƒ½
- [ ] å®ç°å½±å“èŒƒå›´åˆ†æ
- [ ] æ·»åŠ å¾ªç¯ä¾èµ–æ£€æµ‹

#### 2.3 æ•°æ®è®¿é—®å±‚ä¼˜åŒ–
- [ ] ä¼˜åŒ–NebulaæŸ¥è¯¢æ€§èƒ½
- [ ] å®ç°æ‰¹é‡æ“ä½œæ”¯æŒ
- [ ] æ·»åŠ æŸ¥è¯¢ç»“æœç¼“å­˜
- [ ] ä¼˜åŒ–é”™è¯¯å¤„ç†æœºåˆ¶

### é˜¶æ®µä¸‰ï¼šé«˜çº§åŠŸèƒ½å¼€å‘ï¼ˆ2å‘¨ï¼‰

#### 3.1 GraphStatsRouteså®ç°
- [ ] å®ç°å›¾ç»Ÿè®¡ä¿¡æ¯ç«¯ç‚¹
- [ ] æ·»åŠ æ€§èƒ½ç›‘æ§API
- [ ] å®ç°ç¼“å­˜ç»Ÿè®¡åŠŸèƒ½
- [ ] æ·»åŠ å¥åº·æ£€æŸ¥ç«¯ç‚¹

#### 3.2 å®‰å…¨å’Œæƒé™æ§åˆ¶
- [ ] å®ç°APIè®¿é—®æ§åˆ¶
- [ ] æ·»åŠ è¯·æ±‚é¢‘ç‡é™åˆ¶
- [ ] å®ç°æ•°æ®è®¿é—®æƒé™æ£€æŸ¥
- [ ] æ·»åŠ å®‰å…¨æ—¥å¿—è®°å½•

#### 3.3 æ€§èƒ½ä¼˜åŒ–
- [ ] ä¼˜åŒ–æŸ¥è¯¢æ‰§è¡Œè®¡åˆ’
- [ ] å®ç°æŸ¥è¯¢ç»“æœåˆ†é¡µ
- [ ] æ·»åŠ å¼‚æ­¥å¤„ç†æ”¯æŒ
- [ ] ä¼˜åŒ–å†…å­˜ä½¿ç”¨

### é˜¶æ®µå››ï¼šæµ‹è¯•ä¸ä¼˜åŒ–ï¼ˆ1å‘¨ï¼‰

#### 4.1 åŠŸèƒ½æµ‹è¯•
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–æ ¸å¿ƒåŠŸèƒ½
- [ ] é›†æˆæµ‹è¯•éªŒè¯APIäº¤äº’
- [ ] ç«¯åˆ°ç«¯æµ‹è¯•å®Œæ•´æµç¨‹
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•

#### 4.2 ç¨³å®šæ€§ä¼˜åŒ–
- [ ] é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
- [ ] èµ„æºç®¡ç†å’Œé‡Šæ”¾
- [ ] è¶…æ—¶å’Œé‡è¯•æœºåˆ¶
- [ ] ç›‘æ§å’Œå‘Šè­¦é…ç½®

## ğŸ“Š è¯¦ç»†å¼€å‘ä»»åŠ¡

### 1. GraphRoutes - å›¾æ•°æ®ç®¡ç†API

#### 1.1 é¡¹ç›®ç©ºé—´ç®¡ç†
```typescript
// åˆ›å»ºé¡¹ç›®ç©ºé—´ç«¯ç‚¹
POST /api/v1/graph/space/:projectId/create
Request: {
  partitionNum?: number;
  replicaFactor?: number;
  vidType?: string;
}

// åˆ é™¤é¡¹ç›®ç©ºé—´ç«¯ç‚¹
POST /api/v1/graph/space/:projectId/delete

// æ¸…ç©ºé¡¹ç›®ç©ºé—´ç«¯ç‚¹
POST /api/v1/graph/space/:projectId/clear

// è·å–ç©ºé—´ä¿¡æ¯ç«¯ç‚¹
GET /api/v1/graph/space/:projectId/info
```

#### 1.2 å›¾æ•°æ®æ“ä½œ
```typescript
// æ‰¹é‡æ’å…¥èŠ‚ç‚¹
POST /api/v1/graph/nodes
Request: {
  nodes: GraphNode[];
  projectId: string;
}

// æ‰¹é‡æ’å…¥è¾¹
POST /api/v1/graph/edges
Request: {
  edges: GraphEdge[];
  projectId: string;
}

// æ‰¹é‡åˆ é™¤èŠ‚ç‚¹
DELETE /api/v1/graph/nodes
Request: {
  nodeIds: string[];
  projectId: string;
}
```

### 2. GraphQueryRoutes - å›¾æŸ¥è¯¢API

#### 2.1 è‡ªå®šä¹‰æŸ¥è¯¢
```typescript
// æ‰§è¡Œè‡ªå®šä¹‰æŸ¥è¯¢
POST /api/v1/graph/query
Request: {
  query: string;
  projectId: string;
  parameters?: Record<string, any>;
}

// æŸ¥è¯¢ç›¸å…³èŠ‚ç‚¹
POST /api/v1/graph/related
Request: {
  nodeId: string;
  projectId: string;
  relationshipTypes?: string[];
  maxDepth?: number;
  limit?: number;
}
```

#### 2.2 è·¯å¾„æœç´¢
```typescript
// æœ€çŸ­è·¯å¾„æœç´¢
POST /api/v1/graph/path/shortest
Request: {
  sourceId: string;
  targetId: string;
  projectId: string;
  edgeTypes?: string[];
  maxDepth?: number;
}

// æ‰€æœ‰è·¯å¾„æœç´¢
POST /api/v1/graph/path/all
Request: {
  sourceId: string;
  targetId: string;
  projectId: string;
  maxDepth?: number;
}
```

### 3. GraphAnalysisRoutes - å›¾åˆ†æAPI

#### 3.1 ä¾èµ–åˆ†æ
```typescript
// æ–‡ä»¶ä¾èµ–åˆ†æ
POST /api/v1/graph/analysis/dependencies
Request: {
  filePath: string;
  projectId: string;
  includeTransitive?: boolean;
  includeCircular?: boolean;
}

// å¾ªç¯ä¾èµ–æ£€æµ‹
GET /api/v1/graph/analysis/circular/:projectId
```

#### 3.2 è°ƒç”¨å›¾åˆ†æ
```typescript
// å‡½æ•°è°ƒç”¨å›¾
POST /api/v1/graph/analysis/callgraph
Request: {
  functionName: string;
  projectId: string;
  depth?: number;
  direction?: 'in' | 'out' | 'both';
}

// å½±å“èŒƒå›´åˆ†æ
POST /api/v1/graph/analysis/impact
Request: {
  nodeIds: string[];
  projectId: string;
  depth?: number;
}
```

### 4. GraphStatsRoutes - å›¾ç»Ÿè®¡API

#### 4.1 å›¾ç»Ÿè®¡ä¿¡æ¯
```typescript
// è·å–å›¾ç»Ÿè®¡ä¿¡æ¯
GET /api/v1/graph/stats/:projectId

// è·å–ç¼“å­˜ç»Ÿè®¡
GET /api/v1/graph/stats/cache

// è·å–æ€§èƒ½æŒ‡æ ‡
GET /api/v1/graph/stats/performance
```

#### 4.2 ç›‘æ§ç«¯ç‚¹
```typescript
// å¥åº·æ£€æŸ¥
GET /api/v1/graph/stats/health

// æœåŠ¡çŠ¶æ€
GET /api/v1/graph/stats/status
```

## ğŸ”§ æŠ€æœ¯å®ç°ç»†èŠ‚

### 1. APIè·¯ç”±å®ç°

#### 1.1 åŸºç¡€è·¯ç”±ç±»
```typescript
export class GraphRoutes {
  private router: Router;
  private graphService: GraphPersistenceService;
  private projectLookupService: ProjectLookupService;
  
  constructor() {
    this.router = Router();
    this.setupDependencies();
    this.setupRoutes();
  }
  
  private setupRoutes(): void {
    // é¡¹ç›®ç©ºé—´ç®¡ç†è·¯ç”±
    this.router.post('/space/:projectId/create', this.createSpace.bind(this));
    this.router.post('/space/:projectId/delete', this.deleteSpace.bind(this));
    this.router.post('/space/:projectId/clear', this.clearSpace.bind(this));
    this.router.get('/space/:projectId/info', this.getSpaceInfo.bind(this));
    
    // å›¾æ•°æ®æ“ä½œè·¯ç”±
    this.router.post('/nodes', this.insertNodes.bind(this));
    this.router.post('/edges', this.insertEdges.bind(this));
    this.router.delete('/nodes', this.deleteNodes.bind(this));
  }
  
  public getRouter(): Router {
    return this.router;
  }
}
```

#### 1.2 å‚æ•°éªŒè¯å’Œé”™è¯¯å¤„ç†
```typescript
private async createSpace(req: Request, res: Response, next: NextFunction): Promise<void> {
  try {
    // å‚æ•°éªŒè¯
    const { projectId } = req.params;
    const { partitionNum, replicaFactor, vidType } = req.body;
    
    if (!projectId) {
      res.status(400).json({
        success: false,
        error: 'Bad Request',
        message: 'Project ID is required'
      });
      return;
    }
    
    // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    const result = await this.graphService.createSpace(projectId, {
      partitionNum,
      replicaFactor,
      vidType
    });
    
    // è¿”å›ç»“æœ
    res.status(200).json({
      success: true,
      data: result
    });
  } catch (error) {
    next(error);
  }
}
```

### 2. æœåŠ¡å±‚ä¼˜åŒ–

#### 2.1 æŸ¥è¯¢ç¼“å­˜æœºåˆ¶
```typescript
class GraphQueryService {
  private cache: Map<string, { data: any; timestamp: number }>;
  private cacheTTL: number;
  
  async executeQuery(query: string, projectId: string, parameters?: any): Promise<any> {
    // ç”Ÿæˆç¼“å­˜é”®
    const cacheKey = this.generateCacheKey(query, projectId, parameters);
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
      return cached.data;
    }
    
    // æ‰§è¡ŒæŸ¥è¯¢
    const result = await this.nebulaService.executeReadQuery(query, parameters);
    
    // ç¼“å­˜ç»“æœ
    this.cache.set(cacheKey, {
      data: result,
      timestamp: Date.now()
    });
    
    return result;
  }
}
```

#### 2.2 æ‰¹é‡æ“ä½œæ”¯æŒ
```typescript
class GraphPersistenceService {
  async batchInsertNodes(nodes: GraphNode[], projectId: string): Promise<BatchResult> {
    // æŒ‰æ‰¹æ¬¡åˆ†ç»„
    const batches = this.chunkArray(nodes, this.config.batchSize);
    const results: BatchResult[] = [];
    
    for (const batch of batches) {
      const result = await this.insertNodesBatch(batch, projectId);
      results.push(result);
    }
    
    // åˆå¹¶ç»“æœ
    return this.mergeBatchResults(results);
  }
  
  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
  }
}
```

### 3. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 3.1 æŸ¥è¯¢ä¼˜åŒ–
```typescript
class GraphQueryOptimizer {
  optimizeQuery(query: string, options: QueryOptions): OptimizedQuery {
    // è§£ææŸ¥è¯¢è¯­å¥
    const parsed = this.parseQuery(query);
    
    // åº”ç”¨ä¼˜åŒ–è§„åˆ™
    const optimized = this.applyOptimizationRules(parsed, options);
    
    // ç”Ÿæˆä¼˜åŒ–åçš„æŸ¥è¯¢
    return this.generateQuery(optimized);
  }
  
  private applyOptimizationRules(parsed: ParsedQuery, options: QueryOptions): ParsedQuery {
    // åº”ç”¨ç´¢å¼•ä¼˜åŒ–
    if (options.useIndex) {
      parsed = this.applyIndexOptimization(parsed);
    }
    
    // åº”ç”¨è¿‡æ»¤ä¸‹æ¨
    if (options.pushDownFilters) {
      parsed = this.pushDownFilters(parsed);
    }
    
    return parsed;
  }
}
```

#### 3.2 å†…å­˜ç®¡ç†
```typescript
class GraphMemoryManager {
  private memoryThreshold: number;
  
  async checkMemoryUsage(): Promise<boolean> {
    const usage = process.memoryUsage();
    const usedPercent = (usage.heapUsed / usage.heapTotal) * 100;
    
    if (usedPercent > this.memoryThreshold) {
      // è§¦å‘åƒåœ¾å›æ”¶
      if (global.gc) {
        global.gc();
      }
      return false;
    }
    
    return true;
  }
  
  async processWithMemoryCheck<T>(operation: () => Promise<T>): Promise<T> {
    const hasMemory = await this.checkMemoryUsage();
    if (!hasMemory) {
      throw new Error('Insufficient memory for operation');
    }
    
    return operation();
  }
}
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### 1. å•å…ƒæµ‹è¯•

#### 1.1 APIè·¯ç”±æµ‹è¯•
```typescript
describe('GraphRoutes', () => {
  let graphRoutes: GraphRoutes;
  let mockGraphService: jest.Mocked<GraphPersistenceService>;
  
  beforeEach(() => {
    mockGraphService = {
      createSpace: jest.fn(),
      deleteSpace: jest.fn(),
      clearSpace: jest.fn(),
      getSpaceInfo: jest.fn()
    } as any;
    
    graphRoutes = new GraphRoutes(mockGraphService);
  });
  
  describe('createSpace', () => {
    it('should create space successfully', async () => {
      const req = {
        params: { projectId: 'test-project' },
        body: { partitionNum: 10 }
      } as any;
      
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      } as any;
      
      mockGraphService.createSpace.mockResolvedValue(true);
      
      await graphRoutes['createSpace'](req, res, jest.fn());
      
      expect(res.status).toHaveBeenCalledWith(200);
      expect(res.json).toHaveBeenCalledWith({
        success: true,
        data: true
      });
    });
  });
});
```

#### 1.2 æœåŠ¡å±‚æµ‹è¯•
```typescript
describe('GraphPersistenceService', () => {
  let graphService: GraphPersistenceService;
  let mockNebulaService: jest.Mocked<NebulaService>;
  
  beforeEach(() => {
    mockNebulaService = {
      executeWriteQuery: jest.fn(),
      executeReadQuery: jest.fn()
    } as any;
    
    graphService = new GraphPersistenceService(mockNebulaService);
  });
  
  describe('createSpace', () => {
    it('should create space with correct parameters', async () => {
      mockNebulaService.executeWriteQuery.mockResolvedValue(undefined);
      
      const result = await graphService.createSpace('test-project', {
        partitionNum: 10,
        replicaFactor: 1
      });
      
      expect(result).toBe(true);
      expect(mockNebulaService.executeWriteQuery).toHaveBeenCalledWith(
        expect.stringContaining('CREATE SPACE')
      );
    });
  });
});
```

### 2. é›†æˆæµ‹è¯•

#### 2.1 APIé›†æˆæµ‹è¯•
```typescript
describe('Graph API Integration', () => {
  let app: express.Application;
  
  beforeAll(async () => {
    app = await createTestApp();
  });
  
  describe('POST /api/v1/graph/space/:projectId/create', () => {
    it('should create space successfully', async () => {
      const response = await request(app)
        .post('/api/v1/graph/space/test-project/create')
        .send({
          partitionNum: 10,
          replicaFactor: 1
        })
        .expect(200);
      
      expect(response.body.success).toBe(true);
      expect(response.body.data).toBe(true);
    });
  });
});
```

### 3. æ€§èƒ½æµ‹è¯•

#### 3.1 åŸºå‡†æµ‹è¯•
```typescript
describe('Graph API Performance', () => {
  it('should handle concurrent requests', async () => {
    const startTime = Date.now();
    const promises = [];
    
    // å¹¶å‘æ‰§è¡Œ100ä¸ªæŸ¥è¯¢
    for (let i = 0; i < 100; i++) {
      promises.push(
        request(app)
          .post('/api/v1/graph/query')
          .send({
            query: 'MATCH (n) RETURN n LIMIT 10',
            projectId: 'test-project'
          })
      );
    }
    
    const results = await Promise.all(promises);
    const endTime = Date.now();
    
    // éªŒè¯æ‰€æœ‰è¯·æ±‚éƒ½æˆåŠŸ
    results.forEach(result => {
      expect(result.status).toBe(200);
    });
    
    // éªŒè¯æ€»æ—¶é—´åœ¨åˆç†èŒƒå›´å†…
    expect(endTime - startTime).toBeLessThan(5000); // 5ç§’å†…å®Œæˆ
  });
});
```

## ğŸ“ˆ ç›‘æ§å’Œæ—¥å¿—

### 1. æ€§èƒ½ç›‘æ§
```typescript
class GraphPerformanceMonitor {
  private metrics: {
    queryCount: number;
    queryTime: number[];
    errorCount: number;
    cacheHitRate: number;
  };
  
  recordQuery(queryTime: number, success: boolean): void {
    this.metrics.queryCount++;
    
    if (success) {
      this.metrics.queryTime.push(queryTime);
    } else {
      this.metrics.errorCount++;
    }
  }
  
  getMetrics(): PerformanceMetrics {
    return {
      queryCount: this.metrics.queryCount,
      avgQueryTime: this.calculateAverage(this.metrics.queryTime),
      errorRate: this.metrics.errorCount / this.metrics.queryCount,
      cacheHitRate: this.metrics.cacheHitRate
    };
  }
}
```

### 2. æ—¥å¿—è®°å½•
```typescript
class GraphLogger {
  logQuery(query: string, projectId: string, executionTime: number): void {
    this.logger.info('Graph query executed', {
      query: query.substring(0, 100), // åªè®°å½•å‰100ä¸ªå­—ç¬¦
      projectId,
      executionTime,
      timestamp: new Date().toISOString()
    });
  }
  
  logError(error: Error, context: string): void {
    this.logger.error(`Graph operation failed: ${context}`, {
      error: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
  }
}
```

## ğŸ›¡ï¸ å®‰å…¨è€ƒè™‘

### 1. è¾“å…¥éªŒè¯
```typescript
class GraphInputValidator {
  validateQuery(query: string): ValidationResult {
    // æ£€æŸ¥æŸ¥è¯¢é•¿åº¦
    if (query.length > this.config.maxQueryLength) {
      return {
        valid: false,
        error: 'Query too long'
      };
    }
    
    // æ£€æŸ¥å±é™©å…³é”®å­—
    const dangerousKeywords = ['DROP', 'DELETE', 'TRUNCATE'];
    for (const keyword of dangerousKeywords) {
      if (query.toUpperCase().includes(keyword)) {
        return {
          valid: false,
          error: `Dangerous keyword detected: ${keyword}`
        };
      }
    }
    
    return { valid: true };
  }
  
  validateProjectId(projectId: string): ValidationResult {
    // æ£€æŸ¥é¡¹ç›®IDæ ¼å¼
    if (!/^[a-zA-Z0-9-_]+$/.test(projectId)) {
      return {
        valid: false,
        error: 'Invalid project ID format'
      };
    }
    
    return { valid: true };
  }
}
```

### 2. è®¿é—®æ§åˆ¶
```typescript
class GraphAccessController {
  async checkAccess(projectId: string, userId: string): Promise<boolean> {
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰é¡¹ç›®è®¿é—®æƒé™
    const hasAccess = await this.projectService.checkUserAccess(projectId, userId);
    
    if (!hasAccess) {
      this.logger.warn('Unauthorized access attempt', {
        projectId,
        userId,
        timestamp: new Date().toISOString()
      });
    }
    
    return hasAccess;
  }
  
  async rateLimit(userId: string): Promise<boolean> {
    // æ£€æŸ¥ç”¨æˆ·è¯·æ±‚é¢‘ç‡
    const requestCount = await this.rateLimiter.getCount(userId);
    
    if (requestCount > this.config.maxRequestsPerMinute) {
      this.logger.warn('Rate limit exceeded', {
        userId,
        requestCount,
        timestamp: new Date().toISOString()
      });
      
      return false;
    }
    
    return true;
  }
}
```

## ğŸ“š æ–‡æ¡£è®¡åˆ’

### 1. APIæ–‡æ¡£
- OpenAPI/Swaggerè§„èŒƒ
- ç«¯ç‚¹è¯¦ç»†è¯´æ˜
- è¯·æ±‚/å“åº”ç¤ºä¾‹
- é”™è¯¯ç è¯´æ˜

### 2. å¼€å‘æ–‡æ¡£
- æ¶æ„è®¾è®¡è¯´æ˜
- æœåŠ¡å±‚æ¥å£æ–‡æ¡£
- æ•°æ®è®¿é—®å±‚æ–‡æ¡£
- é…ç½®è¯´æ˜

### 3. è¿ç»´æ–‡æ¡£
- éƒ¨ç½²æŒ‡å—
- ç›‘æ§é…ç½®
- æ•…éšœæ’é™¤
- æ€§èƒ½è°ƒä¼˜

## â° æ—¶é—´è§„åˆ’

### æ€»ä½“æ—¶é—´å®‰æ’ï¼š6å‘¨

| é˜¶æ®µ | æ—¶é—´ | ä¸»è¦ä»»åŠ¡ |
|------|------|----------|
| é˜¶æ®µä¸€ | ç¬¬1å‘¨ | åŸºç¡€æ¡†æ¶æ­å»º |
| é˜¶æ®µäºŒ | ç¬¬2-3å‘¨ | æ ¸å¿ƒåŠŸèƒ½å¼€å‘ |
| é˜¶æ®µä¸‰ | ç¬¬4-5å‘¨ | é«˜çº§åŠŸèƒ½å¼€å‘ |
| é˜¶æ®µå›› | ç¬¬6å‘¨ | æµ‹è¯•ä¸ä¼˜åŒ– |

### é‡Œç¨‹ç¢‘è®¡åˆ’

#### é‡Œç¨‹ç¢‘1ï¼šåŸºç¡€æ¡†æ¶å®Œæˆï¼ˆç¬¬1å‘¨æœ«ï¼‰
- å®ŒæˆAPIè·¯ç”±æ¡†æ¶
- å®ç°åŸºç¡€æœåŠ¡ä¾èµ–
- å®ŒæˆåŸºç¡€å·¥å…·ç±»å¼€å‘

#### é‡Œç¨‹ç¢‘2ï¼šæ ¸å¿ƒåŠŸèƒ½å®Œæˆï¼ˆç¬¬3å‘¨æœ«ï¼‰
- å®ç°GraphQueryRoutes
- å®ç°GraphAnalysisRoutes
- å®Œæˆæ•°æ®è®¿é—®å±‚ä¼˜åŒ–

#### é‡Œç¨‹ç¢‘3ï¼šé«˜çº§åŠŸèƒ½å®Œæˆï¼ˆç¬¬5å‘¨æœ«ï¼‰
- å®ç°GraphStatsRoutes
- å®Œæˆå®‰å…¨å’Œæƒé™æ§åˆ¶
- å®ç°æ€§èƒ½ä¼˜åŒ–

#### é‡Œç¨‹ç¢‘4ï¼šæµ‹è¯•å‘å¸ƒå‡†å¤‡ï¼ˆç¬¬6å‘¨æœ«ï¼‰
- å®ŒæˆåŠŸèƒ½æµ‹è¯•
- å®Œæˆæ€§èƒ½ä¼˜åŒ–
- å‡†å¤‡å‘å¸ƒæ–‡æ¡£

## ğŸ‘¥ å›¢é˜Ÿåˆ†å·¥

### åç«¯å¼€å‘äººå‘˜
- è´Ÿè´£APIè·¯ç”±å®ç°
- å®ç°æœåŠ¡å±‚é€»è¾‘
- è¿›è¡Œå•å…ƒæµ‹è¯•

### æ•°æ®åº“ä¸“å®¶
- ä¼˜åŒ–NebulaæŸ¥è¯¢æ€§èƒ½
- è®¾è®¡ç´¢å¼•ç­–ç•¥
- å¤„ç†å¤æ‚æŸ¥è¯¢ä¼˜åŒ–

### æµ‹è¯•å·¥ç¨‹å¸ˆ
- åˆ¶å®šæµ‹è¯•è®¡åˆ’
- æ‰§è¡ŒåŠŸèƒ½æµ‹è¯•
- è¿›è¡Œæ€§èƒ½æµ‹è¯•

### è¿ç»´å·¥ç¨‹å¸ˆ
- é…ç½®ç›‘æ§å‘Šè­¦
- ä¼˜åŒ–éƒ¨ç½²æµç¨‹
- å¤„ç†ç”Ÿäº§ç¯å¢ƒé—®é¢˜

## ğŸ”„ é£é™©ç®¡ç†

### æŠ€æœ¯é£é™©
1. **Nebulaé›†æˆå¤æ‚åº¦**
   - ç¼“è§£ï¼šæ·±å…¥ç ”ç©¶Nebulaæ–‡æ¡£
   - ç¼“è§£ï¼šä¸Nebulaç¤¾åŒºäº¤æµ

2. **æ€§èƒ½é—®é¢˜**
   - ç¼“è§£ï¼šæå‰è¿›è¡Œæ€§èƒ½æµ‹è¯•
   - ç¼“è§£ï¼šå®ç°ç¼“å­˜å’Œä¼˜åŒ–ç­–ç•¥

3. **æ•°æ®ä¸€è‡´æ€§**
   - ç¼“è§£ï¼šå®ç°äº‹åŠ¡æœºåˆ¶
   - ç¼“è§£ï¼šæ·»åŠ æ•°æ®æ ¡éªŒ

### è¿›åº¦é£é™©
1. **åŠŸèƒ½å¼€å‘å»¶æœŸ**
   - ç¼“è§£ï¼šåˆ¶å®šè¯¦ç»†çš„æ—¶é—´è®¡åˆ’
   - ç¼“è§£ï¼šå®šæœŸè¿›åº¦æ£€æŸ¥å’Œè°ƒæ•´

2. **éœ€æ±‚å˜æ›´**
   - ç¼“è§£ï¼šæ¨¡å—åŒ–è®¾è®¡ä¾¿äºè°ƒæ•´
   - ç¼“è§£ï¼šä¸äº§å“å›¢é˜Ÿä¿æŒæ²Ÿé€š

3. **æŠ€æœ¯éš¾é¢˜**
   - ç¼“è§£ï¼šæå‰æŠ€æœ¯è°ƒç ”
   - ç¼“è§£ï¼šå¯»æ±‚å¤–éƒ¨æŠ€æœ¯æ”¯æŒ

## ğŸ“¦ äº¤ä»˜ç‰©

### ä»£ç äº¤ä»˜
- å®Œæ•´çš„APIè·¯ç”±å®ç°
- æœåŠ¡å±‚å’Œæ•°æ®è®¿é—®å±‚ä»£ç 
- æµ‹è¯•ä»£ç å’Œæµ‹è¯•ç”¨ä¾‹
- é…ç½®æ–‡ä»¶å’Œéƒ¨ç½²è„šæœ¬

### æ–‡æ¡£äº¤ä»˜
- APIæ¥å£æ–‡æ¡£
- æŠ€æœ¯æ¶æ„æ–‡æ¡£
- éƒ¨ç½²å’Œè¿ç»´æ–‡æ¡£
- æµ‹è¯•æŠ¥å‘Š

### éƒ¨ç½²äº¤ä»˜
- Dockeré•œåƒ
- Kuberneteséƒ¨ç½²é…ç½®
- ç›‘æ§å’Œå‘Šè­¦é…ç½®
- å›æ»šæ–¹æ¡ˆ

æ­¤å®æ–½è®¡åˆ’å°†æŒ‡å¯¼åç«¯Graph APIçš„å®Œæ•´å¼€å‘è¿‡ç¨‹ï¼Œç¡®ä¿æŒ‰æ—¶äº¤ä»˜é«˜è´¨é‡çš„åŠŸèƒ½ã€‚