
# 分段模块优化方案

## 概述

基于KiloCode的代码块处理经验和边界与重叠处理优化建议，本文档提出了当前项目分段模块的全面优化方案。该方案旨在提高代码分段的语义准确性、边界选择的智能性以及重叠处理的一致性。

## 当前问题分析

### 1. 边界选择问题
- **简单正则匹配**: 当前使用简单的正则表达式检测边界，缺乏语义理解
- **固定阈值策略**: 使用固定百分比阈值，无法适应不同代码结构
- **缺乏语言特异性**: 没有考虑不同编程语言的边界特征

### 2. 重叠处理不一致
- **双重实现**: `OverlapCalculator.ts` 和 `IntelligentSplitterOptimizer.ts` 有不同的重叠计算方法
- **缺乏上下文感知**: 重叠内容选择主要基于字符数量，没有考虑语义价值
- **策略不统一**: 不同分段策略使用不同的重叠计算逻辑

### 3. 策略协调问题
- **策略间缺乏统一**: 各个分段策略独立工作，缺乏统一的边界评估标准
- **降级机制不完善**: 虽然有多级策略，但缺乏智能降级决策

### 4. 性能优化不足
- **缺乏缓存机制**: 除了符号分析缓存，其他组件缺乏缓存
- **重复分析**: 多个组件可能重复分析相同的代码结构

## 优化方案设计

### 1. 语义边界评分机制

#### 1.1 核心组件架构

```typescript
// 新增：SemanticBoundaryAnalyzer.ts
export class SemanticBoundaryAnalyzer {
  /**
   * 计算行作为分割边界的合适度
   * 返回 0-1 的分数，越高越适合作为边界
   */
  calculateBoundaryScore(line: string, context: string[], language: string): BoundaryScore {
    let score = 0;
    const weights = this.getLanguageSpecificWeights(language);
    
    // 1. 基础语法完整性检查 (权重: 0.3)
    if (this.isSyntacticallySafe(line)) {
      score += weights.syntactic * 0.3;
    }
    
    // 2. 语义边界检查 (权重: 0.4)
    if (this.isFunctionEnd(line)) score += weights.function * 0.4;
    if (this.isClassEnd(line)) score += weights.class * 0.4;
    if (this.isMethodEnd(line)) score += weights.method * 0.35;
    if (this.isImportEnd(line)) score += weights.import * 0.2;
    
    // 3. 逻辑分组检查 (权重: 0.2)
    if (this.isEmptyLine(line) && this.hasLogicalSeparation(context)) {
      score += weights.logical * 0.2;
    }
    
    // 4. 注释边界检查 (权重: 0.1)
    if (this.isCommentBlockEnd(line)) score += weights.comment * 0.1;
    
    return {
      score: Math.min(score, 1.0),
      components: {
        syntactic: this.isSyntacticallySafe(line),
        semantic: this.isSemanticBoundary(line),
        logical: this.isLogicalBoundary(line, context),
        comment: this.isCommentBoundary(line)
      }
    };
  }
}
```

#### 1.2 语言特定权重配置

```typescript
interface LanguageWeights {
  syntactic: number;
  function: number;
  class: number;
  method: number;
  import: number;
  logical: number;
  comment: number;
}

const LANGUAGE_WEIGHTS: Record<string, LanguageWeights> = {
  typescript: {
    syntactic: 0.8, function: 0.9, class: 0.9, method: 0.8,
    import: 0.7, logical: 0.6, comment: 0.4
  },
  python: {
    syntactic: 0.7, function: 0.9, class: 0.9, method: 0.8,
    import: 0.8, logical: 0.7, comment: 0.5
  },
  javascript: {
    syntactic: 0.8, function: 0.9, class: 0.9, method: 0.8,
    import: 0.7, logical: 0.6, comment: 0.4
  }
  // 其他语言配置...
};
```

### 2. 统一重叠计算策略


#### 2.1 核心架构

```typescript
// 新增：UnifiedOverlapCalculator.ts
export class UnifiedOverlapCalculator {
  private semanticAnalyzer: SemanticBoundaryAnalyzer;
  private balancedChunker: BalancedChunker;
  private contextAnalyzer: ContextAwareOverlapOptimizer;

  /**
   * 统一的重叠计算方法
   */
  calculateOptimalOverlap(
    currentChunk: CodeChunk,
    nextChunk: CodeChunk,
    originalCode: string,
    options: OverlapOptions
  ): OverlapResult {
    // 1. 选择重叠策略
    const strategy = this.selectOverlapStrategy(currentChunk, nextChunk);
    
    // 2. 根据策略计算重叠
    const baseOverlap = this.calculateBaseOverlap(strategy, currentChunk, nextChunk, originalCode, options);
    
    // 3. 上下文感知优化
    const optimizedOverlap = this.contextAnalyzer.optimizeOverlapForContext(
      baseOverlap, currentChunk, nextChunk
    );
    
    return optimizedOverlap;
  }
}
```

#### 2.2 策略选择机制

```typescript
type OverlapStrategy = 'semantic' | 'syntactic' | 'size-based' | 'hybrid';

private selectOverlapStrategy(currentChunk: CodeChunk, nextChunk: CodeChunk): OverlapStrategy {
  // 根据块类型和内容选择最适合的重叠策略
  if (this.isSequentialFunctions(currentChunk, nextChunk)) {
    return 'semantic';
  }
  
  if (this.isComplexStructure(currentChunk)) {
    return 'syntactic';
  }
  
  if (this.isSimpleCode(currentChunk, nextChunk)) {
    return 'size-based';
  }
  
  return 'hybrid';
}
```

#### 2.3 语义重叠计算

```typescript
private calculateSemanticOverlap(
  currentChunk: CodeChunk,
  nextChunk: CodeChunk,
  originalCode: string,
  options: OverlapOptions
): OverlapResult {
  const overlapLines: string[] = [];
  const lines = originalCode.split('\n');
  
  // 从当前块末尾向前搜索，优先选择语义边界
  for (let i = currentChunk.metadata.endLine - 1; i >= currentChunk.metadata.startLine - 1; i--) {
    if (overlapLines.join('\n').length >= options.maxSize) break;
    
    const line = lines[i];
    const boundaryScore = this.semanticAnalyzer.calculateBoundaryScore(line, [], currentChunk.metadata.language);
    
    // 高评分的边界更有可能被包含在重叠中
    if (boundaryScore.score > 0.6 || overlapLines.length < options.minLines) {
      overlapLines.unshift(line);
    }
  }
  
  return {
    content: overlapLines.join('\n'),
    lines: overlapLines.length,
    strategy: 'semantic',
    quality: this.calculateOverlapQuality(overlapLines, currentChunk, nextChunk)
  };
}
```

#### 2.4 上下文感知优化

```typescript
// 新增：ContextAwareOverlapOptimizer.ts
export class ContextAwareOverlapOptimizer {
  /**
   * 根据上下文优化重叠内容
   */
  optimizeOverlapForContext(
    overlap: OverlapResult,
    currentChunk: CodeChunk,
    nextChunk: CodeChunk
  ): OverlapResult {
    // 分析当前块和下一块的关系
    const relationship = this.analyzeChunkRelationship(currentChunk, nextChunk);
    
    switch (relationship.type) {
      case 'sequential_functions':
        return this.optimizeForSequentialFunctions(overlap, currentChunk, nextChunk);
      case 'class_methods':
        return this.optimizeForClassMethods(overlap, currentChunk, nextChunk);
      case 'related_imports':
        return this.optimizeForRelatedImports(overlap, currentChunk, nextChunk);
      default:
        return overlap;
    }
  }
}
```

### 3. 配置和参数优化方案

#### 3.1 动态参数调整配置

```typescript
// 扩展现有的 ChunkingOptions
export interface AdaptiveChunkingOptions extends ChunkingOptions {
  // 动态调整参数
  adaptiveBoundaryThreshold?: boolean;
  contextAwareOverlap?: boolean;
  semanticWeight?: number;
  syntacticWeight?: number;
  
  // 语义边界评分配置
  boundaryScoring?: {
    enableSemanticScoring: boolean;
    minBoundaryScore: number;
    maxSearchDistance: number;
    languageSpecificWeights: boolean;
  };
  
  // 重叠策略配置
  overlapStrategy?: {
    preferredStrategy: OverlapStrategy;
    enableContextOptimization: boolean

    qualityThreshold: number;
  };
  
  // 针对不同代码类型的专门配置
  functionSpecificOptions?: {
    preferWholeFunctions: boolean;
    minFunctionOverlap: number;
    maxFunctionSize: number;
  };
  
  classSpecificOptions?: {
    keepMethodsTogether: boolean;
    classHeaderOverlap: number;
    maxClassSize: number;
  };
}
```

#### 3.2 语言特定配置

```typescript
// 新增：LanguageSpecificConfig.ts
export interface LanguageSpecificConfig {
  boundaries: {
    functionEnd: RegExp[];
    classEnd: RegExp[];
    methodEnd: RegExp[];
    importEnd: RegExp[];
    statementEnd: RegExp[];
  };
  
  weights: {
    syntactic: number;
    semantic: number;
    logical: number;
    comment: number;
  };
  
  chunking: {
    defaultMaxSize: number;
    defaultOverlap: number;
    preferWholeStructures: boolean;
  };
}

const LANGUAGE_CONFIGS: Record<string, LanguageSpecificConfig> = {
  typescript: {
    boundaries: {
      functionEnd: [/^\s*}\s*$/, /^\s*}\s*\/\/.*$/],
      classEnd: [/^\s*}\s*$/, /^\s*}\s*\/\/.*$/],
      methodEnd: [/^\s*}\s*$/, /^\s*}\s*\/\/.*$/],
      importEnd: [/^import .*;$/, /^export .*;$/],
      statementEnd: [/^\s*;\s*$/, /^\s*}\s*$/]
    },
    weights: {
      syntactic: 0.8, semantic: 0.9, logical: 0.6, comment: 0.4
    },
    chunking: {
      defaultMaxSize: 1000,
      defaultOverlap: 200,
      preferWholeStructures: true
    }
  },
  python: {
    boundaries: {
      functionEnd: [/^\s*$/, /^\s*#.*$/],
      classEnd: [/^\s*$/, /^\s*#.*$/],
      methodEnd: [/^\s*$/, /^\s*#.*$/],
      importEnd: [/^import .*$/, /^from .* import .*$/],
      statementEnd: [/^\s*$/]
    },
    weights: {
      syntactic: 0.7, semantic: 0.9, logical: 0.7, comment: 0.5
    },
    chunking: {
      defaultMaxSize: 1200,
      defaultOverlap: 150,
      preferWholeStructures: true
    }
  }
  // 其他语言配置...
};
```

#### 3.3 性能优化配置

```typescript
// 新增：ChunkingPerformanceOptimizer.ts
export class ChunkingPerformanceOptimizer {
  private analysisCache: Map<string, AnalysisResult> = new Map();
  private boundaryCache: Map<string, BoundaryScore[]> = new Map();
  
  /**
   * 缓存边界分析结果以提高性能
   */
  getCachedBoundaryAnalysis(fileHash: string, lineIndex: number): BoundaryScore | null {
    const cacheKey = `${fileHash}-${lineIndex}`;
    return this.boundaryCache.get(cacheKey) || null;
  }
  
  /**
   * 批量预分析以提高大文件处理速度
   */
  async preAnalyzeFile(content: string, language: string): Promise<PreAnalysisResult> {
    const lines = content.split('\n');
    const boundaryCandidates: BoundaryScore[] = [];
    
    // 并行分析多行
    const batchSize = 100;
    for (let i = 0; i < lines.length; i += batchSize) {
      const batch = lines.slice(i, i + batchSize);
      const batchResults = await Promise.all(
        batch.map((line, index) => this.analyzeLineAsync(line, language, i + index))
      );
      
      boundaryCandidates.push(...batchResults.map((result, index) => ({
        line: i + index,
        score: result.boundaryScore,
        properties: result.properties
      })));
    }
    
    return {
      boundaryCandidates,
      estimatedComplexity: this.calculateOverallComplexity(boundaryCandidates)
    };
  }
}
```

### 4. 改进的分段器架构

#### 4.1 增强的ASTCodeSplitter

```typescript
// 改进：ASTCodeSplitter.ts
@injectable()
export class ASTCodeSplitter implements Splitter {
  // 现有属性...
  
  // 新增组件
  private semanticBoundary

Analyzer: SemanticBoundaryAnalyzer;
  private unifiedOverlapCalculator: UnifiedOverlapCalculator;
  private performanceOptimizer: ChunkingPerformanceOptimizer;
  private languageConfigManager: LanguageSpecificConfigManager;

  constructor(
    @inject(TYPES.TreeSitterService) treeSitterService: TreeSitterService,
    @inject(TYPES.LoggerService) logger?: LoggerService
  ) {
    // 现有初始化代码...
    
    // 新增组件初始化
    this.semanticBoundaryAnalyzer = new SemanticBoundaryAnalyzer();
    this.unifiedOverlapCalculator = new UnifiedOverlapCalculator(this.options);
    this.performanceOptimizer = new ChunkingPerformanceOptimizer();
    this.languageConfigManager = new LanguageSpecificConfigManager();
    
    // 设置依赖关系
    this.unifiedOverlapCalculator.setSemanticBoundaryAnalyzer(this.semanticBoundaryAnalyzer);
    this.unifiedOverlapCalculator.setBalancedChunker(this.balancedChunker);
  }

  async split(code: string, language: string, filePath?: string): Promise<CodeChunk[]> {
    // 处理空代码
    if (!code || code.trim() === '') {
      return [];
    }
    
    // 性能优化：预分析文件
    const preAnalysisResult = await this.performanceOptimizer.preAnalyzeFile(code, language);
    
    // 获取语言特定配置
    const languageConfig = this.languageConfigManager.getConfig(language);
    const adaptiveOptions = this.mergeAdaptiveOptions(this.options, languageConfig);
    
    try {
      const parseResult = await this.treeSitterService.parseCode(code, language);

      if (parseResult.success && parseResult.ast) {
        // 使用增强的语法感知分段器
        return await this.enhancedSyntaxAwareSplit(code, parseResult, language, filePath, adaptiveOptions);
      } else {
        this.logger?.warn(`TreeSitterService failed for language ${language}, falling back to intelligent splitting`);
        return await this.enhancedIntelligentSplit(code, language, filePath, adaptiveOptions);
      }
    } catch (error) {
      this.logger?.warn(`TreeSitterService failed with error: ${error}, using enhanced semantic fallback`);
      return await this.enhancedSemanticSplit(code, language, filePath, adaptiveOptions);
    }
  }

  private async enhancedSyntaxAwareSplit(
    code: string,
    parseResult: any,
    language: string,
    filePath: string | undefined,
    options: Required<AdaptiveChunkingOptions>
  ): Promise<CodeChunk[]> {
    // 使用语义边界评分的语法感知分段
    const chunks = await this.syntaxAwareSplitter.split(code, language, filePath, options);
    
    // 应用统一重叠计算
    if (options.addOverlap && options.overlapStrategy?.enableContextOptimization) {
      return this.unifiedOverlapCalculator.addOverlap(chunks, code);
    }
    
    return chunks;
  }

  private async enhancedIntelligentSplit(
    code: string,
    language: string,
    filePath: string | undefined,
    options: Required<AdaptiveChunkingOptions>
  ): Promise<CodeChunk[]> {
    // 使用语义边界评分的智能分段
    const chunks = await this.intelligentSplitter.split(code, language, filePath, options);
    
    // 应用统一重叠计算
    if (options.addOverlap && options.overlapStrategy?.enableContextOptimization) {
      return this.unifiedOverlapCalculator.addOverlap(chunks, code);
    }
    
    return chunks;
  }

  private async enhancedSemanticSplit(
    code: string,
    language: string,
    filePath: string | undefined,
    options: Required<AdaptiveChunkingOptions>
  ): Promise<CodeChunk[]> {
    // 使用语义边界评分的语义分段
    const chunks = await this.semanticSplitter.split(code, language, filePath, options);
    
    // 应用统一重叠计算
    if (options.addOverlap && options.overlapStrategy?.enableContextOptimization) {
      return this.unifiedOverlapCalculator.addOverlap(chunks, code);
    }
    
    return chunks;
  }
}
```

#### 4.2 增强的IntelligentSplitter

```typescript
// 改进：IntelligentSplitter.ts
export class IntelligentSplitter implements IntelligentSplitterInterface {
  // 现有属性...
  private semanticBoundaryAnalyzer?: SemanticBoundaryAnalyzer;
  private unifiedOverlapCalculator?: UnifiedOverlapCalculator;

  constructor(options?: ChunkingOptions) {
    this.options = { ...DEFAULT_CHUNKING_OPTIONS, ...options };
    this.complexityCalculator = new ComplexityCalculator();
    // 创建一个临时的balancedChunker用于syntaxValidator
    const tempBalancedChunker = new BalancedChunker();
    this.syntaxValidator =

 new SyntaxValidator(tempBalancedChunker);
    this.optimizer = new IntelligentSplitterOptimizer(tempBalancedChunker);
    
    // 初始化语义边界分析器
    this.semanticBoundaryAnalyzer = new SemanticBoundaryAnalyzer();
  }

  setSemanticBoundaryAnalyzer(analyzer: SemanticBoundaryAnalyzer): void {
    this.semanticBoundaryAnalyzer = analyzer;
  }

  setUnifiedOverlapCalculator(calculator: UnifiedOverlapCalculator): void {
    this.unifiedOverlapCalculator = calculator;
  }

  private createIntelligentChunks(
    content: string,
    language: string,
    filePath?: string,
    options: Required<ChunkingOptions> = this.options
  ): CodeChunk[] {
    const startTime = Date.now();
    const chunks: CodeChunk[] = [];
    const lines = content.split('\n');
    let currentChunk: string[] = [];
    let currentLine = 1;
    let currentSize = 0;

    if (!this.balancedChunker) {
      this.balancedChunker = new BalancedChunker(this.logger);
      // 更新optimizer的balancedChunker
      this.optimizer = new IntelligentSplitterOptimizer(this.balancedChunker, this.logger);
    }

    // 获取优化级别
    const optimizationLevel = this.getOptimizationLevel(content);
    this.logger?.debug(`Using optimization level: ${optimizationLevel}`);

    // 重置符号跟踪器
    this.balancedChunker.reset();

    // 根据优化级别决定是否预缓存
    if (optimizationLevel !== 'low') {
      this.balancedChunker.preCacheCommonPatterns();
    }

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const lineSize = line.length + 1; // +1 for newline

      // 更新符号跟踪
      this.balancedChunker.analyzeLineSymbols(line, i + 1);

      // 使用语义边界评分检查是否应该在逻辑边界处分段
      const shouldSplit = this.shouldSplitWithSemanticBoundary(
        line,
        currentChunk,
        currentSize,
        lineSize,
        this.options.maxChunkSize,
        language,
        lines,
        i
      );

      if (shouldSplit && currentChunk.length > 0) {
        const chunkContent = currentChunk.join('\n');

        // 验证分段语法
        if (this.syntaxValidator.validate(chunkContent, language)) {
          const complexity = this.complexityCalculator.calculate(chunkContent);

          const metadata: CodeChunkMetadata = {
            startLine: currentLine,
            endLine: currentLine + currentChunk.length - 1,
            language,
            filePath,
            type: 'generic',
            complexity
          };

          chunks.push({
            content: chunkContent,
            metadata
          });

          // 使用统一重叠计算
          if (this.unifiedOverlapCalculator) {
            const overlapResult = this.unifiedOverlapCalculator.calculateOptimalOverlap(
              chunks[chunks.length - 1],
              { content: '', metadata: { startLine: i + 2, endLine: i + 2, language } as CodeChunkMetadata },
              content,
              { maxSize: this.options.overlapSize, minLines: 1 }
            );
            currentChunk = overlapResult.content.split('\n');
            currentLine = i - overlapResult.lines + 1;
            currentSize = overlapResult.content.length;
          } else {
            // 回退到原有逻辑
            const overlapLines = this.optimizer.calculateSmartOverlap(
              currentChunk,
              content,
              this.options.overlapSize
            );
            currentChunk = overlapLines;
            currentLine = i - overlapLines.length + 1;
            currentSize = overlapLines.join('\n').length;
          }
        } else {
          this.logger?.warn(`Skipping chunk due to syntax validation failure at line ${currentLine}`);
          // 如果验证失败，尝试在下一个安全点分段
          continue;
        }
      }

      currentChunk.push(line);
      currentSize += lineSize;
    }

    // 处理最后的chunk
    if (currentChunk.length > 0) {
      const chunkContent = currentChunk.join('\n');

      // 验证最后一段的语法
      if (this.syntaxValidator.validate(chunkContent, language)) {
        const complexity = this.complexityCalculator.calculate(chunkContent);

        const metadata: CodeChunkMetadata = {
          startLine: currentLine,
          endLine: currentLine + currentChunk.length - 1,
          language,
          filePath,
          type: 'generic',
          complexity
        };

        chunks.push({
          content: chunkContent,
          metadata
        });
      }


    }

    // 记录性能指标
    const endTime = Date.now();
    const duration = endTime - startTime;
    this.logger?.debug(`Performance metrics: processed ${lines.length} lines in ${duration}ms, generated ${chunks.length} chunks`);
    
    return chunks;
  }

  /**
   * 使用语义边界评分的分割决策
   */
  private shouldSplitWithSemanticBoundary(
    line: string,
    currentChunk: string[],
    currentSize: number,
    lineSize: number,
    maxChunkSize: number,
    language: string,
    allLines: string[],
    currentIndex: number
  ): boolean {
    // 大小限制检查（优先）
    if (currentSize + lineSize > maxChunkSize) {
      return true;
    }

    // 符号平衡检查 - 只有在符号平衡时才允许分段
    if (!this.balancedChunker.canSafelySplit()) {
      return false;
    }

    // 使用语义边界评分
    if (this.semanticBoundaryAnalyzer) {
      const context = allLines.slice(Math.max(0, currentIndex - 2), currentIndex + 1);
      const boundaryScore = this.semanticBoundaryAnalyzer.calculateBoundaryScore(line, context, language);
      
      // 如果边界评分足够高，允许分段
      if (boundaryScore.score > 0.7) {
        return currentSize > maxChunkSize * 0.3;
      }
      
      // 如果边界评分中等，需要更大的块大小
      if (boundaryScore.score > 0.5) {
        return currentSize > maxChunkSize * 0.5;
      }
    }

    // 回退到原有逻辑
    return this.optimizer.shouldSplitAtLineWithSymbols(
      line,
      currentChunk,
      currentSize,
      lineSize,
      maxChunkSize
    );
  }
}
```

### 5. 测试用例改进

#### 5.1 语义边界测试

```typescript
// 新增：__tests__/SemanticBoundaryAnalyzer.test.ts
describe('SemanticBoundaryAnalyzer', () => {
  let analyzer: SemanticBoundaryAnalyzer;

  beforeEach(() => {
    analyzer = new SemanticBoundaryAnalyzer();
  });

  describe('calculateBoundaryScore', () => {
    it('should give high score to function boundaries', () => {
      const line = '  }';
      const context = ['function test() {', '  return true;', '  }'];
      const score = analyzer.calculateBoundaryScore(line, context, 'typescript');
      
      expect(score.score).toBeGreaterThan(0.7);
      expect(score.components.semantic).toBe(true);
    });

    it('should give high score to class boundaries', () => {
      const line = '}';
      const context = ['class TestClass {', '  constructor() {}', '}'];
      const score = analyzer.calculateBoundaryScore(line, context, 'typescript');
      
      expect(score.score).toBeGreaterThan(0.7);
      expect(score.components.semantic).toBe(true);
    });

    it('should give moderate score to logical boundaries', () => {
      const line = '';
      const context = ['const x = 1;', '', 'const y = 2;'];
      const score = analyzer.calculateBoundaryScore(line, context, 'typescript');
      
      expect(score.score).toBeGreaterThan(0.3);
      expect(score.components.logical).toBe(true);
    });

    it('should give low score to non-boundaries', () => {
      const line = '  const x = 1;';
      const context = ['function test() {', '  const x = 1;', '  return x;'];
      const score = analyzer.calculateBoundaryScore(line, context, 'typescript');
      
      expect(score.score).toBeLessThan(0.3);
    });
  });
});
```

#### 5.2 统一重叠计算测试

```typescript
// 新增：__tests__/UnifiedOverlapCalculator.test.ts
describe('UnifiedOverlapCalculator', () => {
  let calculator: UnifiedOverlapCalculator;
  let semanticAnalyzer: SemanticBoundaryAnalyzer;
  let balancedChunker: BalancedChunker;

  beforeEach(() => {
    semanticAnalyzer = new SemanticBoundaryAnalyzer();
    balancedChunker = new BalancedChunker();
    calculator = new UnifiedOverlapCalculator();
    calculator.setSemanticBoundaryAnalyzer(semanticAnalyzer);
    calculator.setBalancedChunker(balancedChunker);
  });

  describe('calculateOptimalOverlap', () => {
    it('should use semantic strategy for sequential functions', () => {
      const currentChunk: CodeChunk = {
        content: 'function first() {\n  return "first";\n}',
        metadata: { startLine:

 1, endLine: 3, language: 'typescript' } as CodeChunkMetadata
      };
      const nextChunk: CodeChunk = {
        content: 'function second() {\n  return "second";\n}',
        metadata: { startLine: 5, endLine: 7, language: 'typescript' } as CodeChunkMetadata
      };
      const originalCode = 'function first() {\n  return "first";\n}\n\nfunction second() {\n  return "second";\n}';

      const result = calculator.calculateOptimalOverlap(
        currentChunk,
        nextChunk,
        originalCode,
        { maxSize: 100, minLines: 1 }
      );

      expect(result.strategy).toBe('semantic');
      expect(result.content).toContain('function first()');
    });

    it('should use syntactic strategy for complex structures', () => {
      const currentChunk: CodeChunk = {
        content: 'class ComplexClass {\n  constructor() {\n    this.data = [];\n  }',
        metadata: { startLine: 1, endLine: 4, language: 'typescript' } as CodeChunkMetadata
      };
      const nextChunk: CodeChunk = {
        content: '  method() {\n    return this.data;\n  }\n}',
        metadata: { startLine: 5, endLine: 8, language: 'typescript' } as CodeChunkMetadata
      };
      const originalCode = 'class ComplexClass {\n  constructor() {\n    this.data = [];\n  }\n  method() {\n    return this.data;\n  }\n}';

      const result = calculator.calculateOptimalOverlap(
        currentChunk,
        nextChunk,
        originalCode,
        { maxSize: 100, minLines: 1 }
      );

      expect(result.strategy).toBe('syntactic');
    });
  });
});
```

### 6. 实现计划和优先级建议

#### 6.1 实施阶段

**阶段一：核心组件实现（2-3周）**
1. 实现 `SemanticBoundaryAnalyzer` 类
2. 实现 `UnifiedOverlapCalculator` 类
3. 实现 `LanguageSpecificConfigManager` 类
4. 实现 `ChunkingPerformanceOptimizer` 类

**阶段二：集成现有组件（1-2周）**
1. 改进 `IntelligentSplitter` 集成语义边界评分
2. 改进 `ASTCodeSplitter` 集成统一重叠计算
3. 更新 `ChunkingOptions` 接口支持新配置
4. 实现上下文感知重叠优化

**阶段三：测试和优化（1-2周）**
1. 编写全面的单元测试
2. 性能基准测试和优化
3. 集成测试和边界情况处理
4. 文档更新和代码示例

#### 6.2 优先级建议

**高优先级：**
1. 语义边界评分机制 - 核心改进，直接影响分段质量
2. 统一重叠计算策略 - 解决当前不一致问题

**中优先级：**
3. 语言特定配置 - 提高不同语言的适配性
4. 性能优化组件 - 提高大文件处理效率

**低优先级：**
5. 高级上下文感知优化 - 增强功能，可后续迭代
6. 动态参数调整 - 高级功能，根据实际需求决定

#### 6.3 风险评估和缓解策略

**风险1：性能影响**
- 实施：缓存机制和批量分析
- 监控：性能基准测试
- 缓解：渐进式部署，可配置开关

**风险2：兼容性问题**
- 实施：保持现有API兼容
- 监控：回归测试
- 缓解：提供迁移指南和配置选项

**风险3：复杂性增加**
- 实施：清晰的模块设计和文档
- 监控：代码审查和测试覆盖率
- 缓解：分阶段实施，逐步验证

### 7. 预期效果

#### 7.1 质量提升
- **边界准确性**：语义边界评分将提高分段边界的语义准确性，减少在代码结构中间断开的情况
- **重叠质量**：统一重叠计算策略将提供更一致和语义相关的重叠内容
- **语言适配性**：语言特定配置将提高不同编程语言的分段质量

#### 7.2 性能优化
- **缓存效率**：多级缓存机制将减少
重复分析，提高大文件处理速度
- **内存使用**：批量处理和缓存策略将优化内存使用
- **并行处理**：支持并行分析多个代码段

#### 7.3 扩展性提升
- **语言支持**：模块化设计便于添加新语言支持
- **策略扩展**：插件化的分段策略便于定制和扩展
- **配置灵活性**：丰富的配置选项满足不同场景需求

### 8. 结论

本优化方案基于KiloCode的代码块处理经验和边界与重叠处理优化建议，全面改进了当前项目的分段模块。通过引入语义边界评分机制、统一重叠计算策略和语言特定配置，将显著提高代码分段的准确性、一致性和性能。

方案采用渐进式实施策略，优先解决核心问题，同时保持向后兼容性。通过合理的风险控制和测试策略，确保优化过程的稳定性和可靠性。

预期实施后，分段模块将能够：
1. 更准确地识别语义边界，减少在代码结构中间断开的情况
2. 提供一致且语义相关的重叠内容
3. 更好地适应不同编程语言的特性
4. 提高大文件处理的性能和效率

这些改进将为代码索引、AI理解和文档生成等下游应用提供更高质量的代码片段，提升整体系统的用户体验和效果。