import { injectable, inject } from 'inversify';
import { TYPES } from '../../types';
import { LoggerService } from '../../utils/LoggerService';
import { ErrorHandlerService } from '../../utils/ErrorHandlerService';
import { ConfigService } from '../../config/ConfigService';
import { FileChunk } from '../index/IndexSyncService';
import fs from 'fs/promises';
import path from 'path';

export interface SmartIndexingOptions {
  enableCodeStructureAnalysis?: boolean;
  enableImportanceAnalysis?: boolean;
  enableSemanticChunking?: boolean;
  maxChunkSize?: number;
  minChunkSize?: number;
  chunkOverlap?: number;
  importanceThreshold?: number;
}

export interface CodeStructure {
  functions: FunctionInfo[];
  classes: ClassInfo[];
  imports: ImportInfo[];
  exports: ExportInfo[];
}

export interface FunctionInfo {
  name: string;
  startLine: number;
  endLine: number;
  parameters: string[];
  returnType?: string;
  accessibility?: 'public' | 'private' | 'protected';
  isAsync: boolean;
  isStatic: boolean;
}

export interface ClassInfo {
  name: string;
  startLine: number;
  endLine: number;
  methods: FunctionInfo[];
  properties: PropertyInfo[];
  extends?: string;
  implements?: string[];
  isAbstract: boolean;
}

export interface PropertyInfo {
  name: string;
  type?: string;
  accessibility?: 'public' | 'private' | 'protected';
  isStatic: boolean;
  isReadonly: boolean;
}

export interface ImportInfo {
  module: string;
  importedItems: string[];
  isDefault: boolean;
  isNamed: boolean;
  isNamespace: boolean;
  startLine: number;
}

export interface ExportInfo {
  name: string;
  isDefault: boolean;
  isNamed: boolean;
  startLine: number;
}

export interface FileImportance {
  overall: number;
  structural: number;
  functional: number;
  dependency: number;
  factors: {
    isEntryFile: boolean;
    isTestFile: boolean;
    isConfigFile: boolean;
    exportCount: number;
    importCount: number;
    functionCount: number;
    classCount: number;
    lineCount: number;
    complexity: number;
  };
}

@injectable()
export class SmartIndexingStrategy {
  private options: Required<SmartIndexingOptions>;

  constructor(
    @inject(TYPES.LoggerService) private logger: LoggerService,
    @inject(TYPES.ErrorHandlerService) private errorHandler: ErrorHandlerService,
    @inject(TYPES.ConfigService) private configService: ConfigService
  ) {
    // 初始化选项
    this.options = {
      enableCodeStructureAnalysis: this.configService.get('smartIndexing')?.enableCodeStructureAnalysis ?? true,
      enableImportanceAnalysis: this.configService.get('smartIndexing')?.enableImportanceAnalysis ?? true,
      enableSemanticChunking: this.configService.get('smartIndexing')?.enableSemanticChunking ?? true,
      maxChunkSize: this.configService.get('smartIndexing')?.maxChunkSize ?? 500,
      minChunkSize: this.configService.get('smartIndexing')?.minChunkSize ?? 50,
      chunkOverlap: this.configService.get('smartIndexing')?.chunkOverlap ?? 20,
      importanceThreshold: this.configService.get('smartIndexing')?.importanceThreshold ?? 0.5
    };

    this.logger.info('Smart indexing strategy initialized', { options: this.options });
  }

  /**
   * 智能分块文件内容
   */
  async smartChunkFile(filePath: string, content: string): Promise<FileChunk[]> {
    try {
      const language = this.detectLanguage(filePath);
      
      if (this.options.enableSemanticChunking && this.supportsSemanticChunking(language)) {
        return await this.semanticChunking(filePath, content, language);
      } else {
        return this.fallbackChunking(filePath, content, language);
      }
    } catch (error) {
      this.errorHandler.handleError(
        new Error(`Failed to smart chunk file: ${error instanceof Error ? error.message : String(error)}`),
        { component: 'SmartIndexingStrategy', operation: 'smartChunkFile', filePath }
      );
      // 回退到基本分块
      return this.basicChunking(filePath, content);
    }
  }

  /**
   * 语义分块
   */
  private async semanticChunking(filePath: string, content: string, language: string): Promise<FileChunk[]> {
    const chunks: FileChunk[] = [];
    
    try {
      // 分析代码结构
      let codeStructure: CodeStructure | null = null;
      if (this.options.enableCodeStructureAnalysis) {
        codeStructure = await this.analyzeCodeStructure(content, language);
      }
      
      // 分析文件重要性
      let fileImportance: FileImportance | null = null;
      if (this.options.enableImportanceAnalysis) {
        fileImportance = await this.analyzeFileImportance(filePath, content, codeStructure);
      }
      
      // 基于代码结构和重要性进行分块
      if (codeStructure) {
        // 优先按函数和类分块
        chunks.push(...this.chunkByFunctions(content, filePath, language, codeStructure));
        chunks.push(...this.chunkByClasses(content, filePath, language, codeStructure));
      }
      
      // 如果没有足够的结构化块，使用语义分块
      if (chunks.length === 0) {
        chunks.push(...this.chunkBySemantics(content, filePath, language));
      }
      
      // 如果仍然没有足够的块，使用回退分块
      if (chunks.length === 0) {
        return this.fallbackChunking(filePath, content, language);
      }
      
      return chunks;
    } catch (error) {
      this.logger.warn(`Semantic chunking failed for ${filePath}, falling back to basic chunking`, { error });
      return this.basicChunking(filePath, content);
    }
  }

  /**
   * 回退分块
   */
  private fallbackChunking(filePath: string, content: string, language: string): Promise<FileChunk[]> {
    return Promise.resolve(this.basicChunking(filePath, content));
  }

  /**
   * 基本分块
   */
  private basicChunking(filePath: string, content: string): FileChunk[] {
    const lines = content.split('\n');
    const chunks: FileChunk[] = [];
    
    // 简单的按行分割策略
    const chunkSize = Math.min(this.options.maxChunkSize, Math.max(this.options.minChunkSize, 100));
    const chunkOverlap = Math.min(this.options.chunkOverlap, Math.floor(chunkSize / 2));
    
    for (let i = 0; i < lines.length; i += chunkSize - chunkOverlap) {
      const startLine = i;
      const endLine = Math.min(i + chunkSize, lines.length);
      const chunkContent = lines.slice(startLine, endLine).join('\n');
      
      chunks.push({
        content: chunkContent,
        filePath,
        startLine: startLine + 1,
        endLine: endLine,
        language: this.detectLanguage(filePath),
        chunkType: 'code'
      });
    }
    
    return chunks;
  }

  /**
   * 检测语言
   */
  private detectLanguage(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    
    const languageMap: Record<string, string> = {
      '.js': 'javascript',
      '.ts': 'typescript',
      '.jsx': 'javascript',
      '.tsx': 'typescript',
      '.py': 'python',
      '.java': 'java',
      '.cpp': 'cpp',
      '.c': 'c',
      '.h': 'cpp',
      '.cs': 'csharp',
      '.go': 'go',
      '.rs': 'rust',
      '.php': 'php',
      '.rb': 'ruby',
      '.swift': 'swift',
      '.kt': 'kotlin',
      '.scala': 'scala',
      '.md': 'markdown',
      '.json': 'json',
      '.xml': 'xml',
      '.yaml': 'yaml',
      '.yml': 'yaml',
      '.sql': 'sql',
      '.sh': 'shell',
      '.bash': 'shell',
      '.zsh': 'shell',
      '.fish': 'shell',
      '.html': 'html',
      '.css': 'css',
      '.scss': 'scss',
      '.sass': 'sass',
      '.less': 'less',
      '.vue': 'vue',
      '.svelte': 'svelte'
    };
    
    return languageMap[ext] || 'unknown';
  }

  /**
   * 检查是否支持语义分块
   */
  private supportsSemanticChunking(language: string): boolean {
    const supportedLanguages = [
      'javascript',
      'typescript',
      'python',
      'java',
      'cpp',
      'c',
      'csharp',
      'go',
      'rust',
      'php',
      'ruby'
    ];
    
    return supportedLanguages.includes(language);
  }

  /**
   * 分析代码结构
   */
  private async analyzeCodeStructure(content: string, language: string): Promise<CodeStructure> {
    // 这是一个简化的实现，实际应用中可能需要使用专门的解析器
    // 如 TypeScript 的 ts-morph，Python 的 ast 模块等
    
    const functions: FunctionInfo[] = [];
    const classes: ClassInfo[] = [];
    const imports: ImportInfo[] = [];
    const exports: ExportInfo[] = [];
    
    const lines = content.split('\n');
    
    // 简单的正则表达式匹配，实际应用中应该使用更复杂的解析器
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // 匹配函数声明
      const functionMatch = line.match(/^(async\s+)?(function\s+|(\w+)\s*\()(\w+)\s*\(/);
      if (functionMatch) {
        const isAsync = !!functionMatch[1];
        const name = functionMatch[4];
        
        // 查找函数结束位置
        let endLine = i + 1;
        let braceCount = 0;
        let foundBrace = false;
        
        for (let j = i; j < lines.length; j++) {
          const lineContent = lines[j];
          for (let k = 0; k < lineContent.length; k++) {
            if (lineContent[k] === '{') {
              braceCount++;
              foundBrace = true;
            } else if (lineContent[k] === '}') {
              braceCount--;
              if (braceCount === 0 && foundBrace) {
                endLine = j + 1;
                break;
              }
            }
          }
          if (braceCount === 0 && foundBrace) {
            break;
          }
        }
        
        functions.push({
          name,
          startLine: i + 1,
          endLine,
          parameters: [], // 简化实现，实际应该解析参数
          isAsync,
          isStatic: line.includes('static'),
          accessibility: this.extractAccessibility(line)
        });
      }
      
      // 匹配类声明
      const classMatch = line.match(/^class\s+(\w+)/);
      if (classMatch) {
        const name = classMatch[1];
        
        // 查找类结束位置
        let endLine = i + 1;
        let braceCount = 0;
        let foundBrace = false;
        
        for (let j = i; j < lines.length; j++) {
          const lineContent = lines[j];
          for (let k = 0; k < lineContent.length; k++) {
            if (lineContent[k] === '{') {
              braceCount++;
              foundBrace = true;
            } else if (lineContent[k] === '}') {
              braceCount--;
              if (braceCount === 0 && foundBrace) {
                endLine = j + 1;
                break;
              }
            }
          }
          if (braceCount === 0 && foundBrace) {
            break;
          }
        }
        
        classes.push({
          name,
          startLine: i + 1,
          endLine,
          methods: [], // 简化实现，实际应该解析方法
          properties: [], // 简化实现，实际应该解析属性
          isAbstract: line.includes('abstract')
        });
      }
      
      // 匹配导入声明
      const importMatch = line.match(/^import\s+(.+)\s+from\s+['"](.+)['"]/);
      if (importMatch) {
        const importedItems = importMatch[1].trim();
        const module = importMatch[2];
        
        imports.push({
          module,
          importedItems: importedItems === '*' ? ['*'] : importedItems.split(',').map(item => item.trim()),
          isDefault: importedItems !== '*' && !importedItems.includes('{'),
          isNamed: importedItems.includes('{'),
          isNamespace: importedItems.includes('*'),
          startLine: i + 1
        });
      }
      
      // 匹配导出声明
      const exportMatch = line.match(/^export\s+(default\s+)?(\w+|\{.*\})/);
      if (exportMatch) {
        const isDefault = !!exportMatch[1];
        const name = exportMatch[2];
        
        exports.push({
          name,
          isDefault,
          isNamed: !isDefault,
          startLine: i + 1
        });
      }
    }
    
    return {
      functions,
      classes,
      imports,
      exports
    };
  }

  /**
   * 提取访问修饰符
   */
  private extractAccessibility(line: string): 'public' | 'private' | 'protected' {
    if (line.includes('private')) return 'private';
    if (line.includes('protected')) return 'protected';
    return 'public';
  }

  /**
   * 分析文件重要性
   */
  private async analyzeFileImportance(
    filePath: string, 
    content: string, 
    codeStructure: CodeStructure | null
  ): Promise<FileImportance> {
    const factors = {
      isEntryFile: this.isEntryFile(filePath),
      isTestFile: this.isTestFile(filePath),
      isConfigFile: this.isConfigFile(filePath),
      exportCount: codeStructure?.exports.length || 0,
      importCount: codeStructure?.imports.length || 0,
      functionCount: codeStructure?.functions.length || 0,
      classCount: codeStructure?.classes.length || 0,
      lineCount: content.split('\n').length,
      complexity: this.calculateComplexity(content, codeStructure)
    };
    
    // 计算各个维度的重要性
    const structural = this.calculateStructuralImportance(factors);
    const functional = this.calculateFunctionalImportance(factors);
    const dependency = this.calculateDependencyImportance(factors);
    
    // 计算总体重要性
    const overall = (structural + functional + dependency) / 3;
    
    return {
      overall,
      structural,
      functional,
      dependency,
      factors
    };
  }

  /**
   * 判断是否为入口文件
   */
  private isEntryFile(filePath: string): boolean {
    const fileName = path.basename(filePath, path.extname(filePath));
    const entryFileNames = ['index', 'main', 'app', 'server'];
    return entryFileNames.includes(fileName.toLowerCase());
  }

  /**
   * 判断是否为测试文件
   */
  private isTestFile(filePath: string): boolean {
    const fileName = path.basename(filePath).toLowerCase();
    return fileName.includes('.test.') || 
           fileName.includes('.spec.') || 
           fileName.includes('test.') ||
           fileName.startsWith('test_') ||
           path.dirname(filePath).toLowerCase().includes('test') ||
           path.dirname(filePath).toLowerCase().includes('__tests__');
  }

  /**
   * 判断是否为配置文件
   */
  private isConfigFile(filePath: string): boolean {
    const fileName = path.basename(filePath).toLowerCase();
    const configFileNames = [
      'config', 'settings', 'env', '.env', 
      'package.json', 'tsconfig.json', 'webpack.config.js',
      'babel.config.js', '.eslintrc', '.gitignore'
    ];
    return configFileNames.some(name => fileName.includes(name) || fileName === name);
  }

  /**
   * 计算代码复杂度
   */
  private calculateComplexity(content: string, codeStructure: CodeStructure | null): number {
    // 简化的复杂度计算，实际应用中可以使用更复杂的算法
    let complexity = 0;
    
    // 基于控制流语句增加复杂度
    const controlFlowPatterns = [
      /\bif\b/g, /\belse\b/g, /\bfor\b/g, /\bwhile\b/g, 
      /\bdo\b/g, /\bswitch\b/g, /\btry\b/g, /\bcatch\b/g
    ];
    
    for (const pattern of controlFlowPatterns) {
      const matches = content.match(pattern);
      if (matches) {
        complexity += matches.length;
      }
    }
    
    // 基于嵌套层次增加复杂度
    const lines = content.split('\n');
    let maxNestingLevel = 0;
    let currentNestingLevel = 0;
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      // 增加嵌套层次
      if (trimmedLine.endsWith('{')) {
        currentNestingLevel++;
        maxNestingLevel = Math.max(maxNestingLevel, currentNestingLevel);
      }
      
      // 减少嵌套层次
      if (trimmedLine.startsWith('}')) {
        currentNestingLevel = Math.max(0, currentNestingLevel - 1);
      }
    }
    
    complexity += maxNestingLevel * 2;
    
    // 基于函数和类数量增加复杂度
    if (codeStructure) {
      complexity += codeStructure.functions.length * 2;
      complexity += codeStructure.classes.length * 3;
    }
    
    return complexity;
  }

  /**
   * 计算结构重要性
   */
  private calculateStructuralImportance(factors: FileImportance['factors']): number {
    let importance = 0;
    
    // 入口文件和配置文件有更高的结构重要性
    if (factors.isEntryFile) importance += 0.8;
    if (factors.isConfigFile) importance += 0.6;
    
    // 导出和导入数量反映结构重要性
    importance += Math.min(factors.exportCount * 0.1, 0.5);
    importance += Math.min(factors.importCount * 0.05, 0.3);
    
    // 类和函数数量反映结构重要性
    importance += Math.min(factors.classCount * 0.15, 0.5);
    importance += Math.min(factors.functionCount * 0.1, 0.4);
    
    return Math.min(importance, 1);
  }

  /**
   * 计算功能重要性
   */
  private calculateFunctionalImportance(factors: FileImportance['factors']): number {
    let importance = 0;
    
    // 测试文件功能重要性较低
    if (factors.isTestFile) importance += 0.2;
    
    // 功能数量反映功能重要性
    importance += Math.min(factors.functionCount * 0.15, 0.6);
    importance += Math.min(factors.classCount * 0.1, 0.4);
    
    // 代码行数反映功能重要性
    importance += Math.min(factors.lineCount / 1000 * 0.3, 0.5);
    
    // 复杂度反映功能重要性
    importance += Math.min(factors.complexity / 50 * 0.2, 0.4);
    
    return Math.min(importance, 1);
  }

  /**
   * 计算依赖重要性
   */
  private calculateDependencyImportance(factors: FileImportance['factors']): number {
    let importance = 0;
    
    // 入口文件依赖重要性较高
    if (factors.isEntryFile) importance += 0.7;
    
    // 导入和导出数量反映依赖重要性
    importance += Math.min(factors.importCount * 0.15, 0.6);
    importance += Math.min(factors.exportCount * 0.2, 0.7);
    
    return Math.min(importance, 1);
  }

  /**
   * 按函数分块
   */
  private chunkByFunctions(
    content: string, 
    filePath: string, 
    language: string, 
    codeStructure: CodeStructure
  ): FileChunk[] {
    const chunks: FileChunk[] = [];
    const lines = content.split('\n');
    
    for (const func of codeStructure.functions) {
      // 确保函数在文件范围内
      if (func.startLine < 1 || func.endLine > lines.length) continue;
      
      const funcContent = lines.slice(func.startLine - 1, func.endLine).join('\n');
      
      chunks.push({
        content: funcContent,
        filePath,
        startLine: func.startLine,
        endLine: func.endLine,
        language,
        chunkType: 'function',
        functionName: func.name
      });
    }
    
    return chunks;
  }

  /**
   * 按类分块
   */
  private chunkByClasses(
    content: string, 
    filePath: string, 
    language: string, 
    codeStructure: CodeStructure
  ): FileChunk[] {
    const chunks: FileChunk[] = [];
    const lines = content.split('\n');
    
    for (const cls of codeStructure.classes) {
      // 确保类在文件范围内
      if (cls.startLine < 1 || cls.endLine > lines.length) continue;
      
      const classContent = lines.slice(cls.startLine - 1, cls.endLine).join('\n');
      
      chunks.push({
        content: classContent,
        filePath,
        startLine: cls.startLine,
        endLine: cls.endLine,
        language,
        chunkType: 'class',
        className: cls.name
      });
    }
    
    return chunks;
  }

  /**
   * 按语义分块
   */
  private chunkBySemantics(content: string, filePath: string, language: string): FileChunk[] {
    const chunks: FileChunk[] = [];
    const lines = content.split('\n');
    
    // 简化的语义分块实现，实际应用中可以使用更复杂的算法
    // 这里我们按注释和空行分割代码块
    
    let currentChunkStart = 0;
    let lastCommentLine = -1;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // 检查是否为注释行
      const isComment = this.isCommentLine(line, language);
      
      // 如果是注释行或者空行，并且距离上一个注释行有一定距离，则创建一个新的块
      if ((isComment || line === '') && i - lastCommentLine > 5) {
        if (i - currentChunkStart >= this.options.minChunkSize) {
          const chunkContent = lines.slice(currentChunkStart, i).join('\n');
          
          chunks.push({
            content: chunkContent,
            filePath,
            startLine: currentChunkStart + 1,
            endLine: i,
            language,
            chunkType: 'code'
          });
          
          currentChunkStart = i;
        }
        
        if (isComment) {
          lastCommentLine = i;
        }
      }
    }
    
    // 添加最后一个块
    if (lines.length - currentChunkStart >= this.options.minChunkSize) {
      const chunkContent = lines.slice(currentChunkStart).join('\n');
      
      chunks.push({
        content: chunkContent,
        filePath,
        startLine: currentChunkStart + 1,
        endLine: lines.length,
        language,
        chunkType: 'code'
      });
    }
    
    return chunks;
  }

  /**
   * 判断是否为注释行
   */
  private isCommentLine(line: string, language: string): boolean {
    if (line === '') return false;
    
    const commentPatterns: Record<string, RegExp[]> = {
      javascript: [/^\/\//, /^\/\*/, /^\*\//],
      typescript: [/^\/\//, /^\/\*/, /^\*\//],
      python: [/^#/, /^'''/, /^"""/],
      java: [/^\/\//, /^\/\*/, /^\*\//],
      cpp: [/^\/\//, /^\/\*/, /^\*\//],
      c: [/^\/\//, /^\/\*/, /^\*\//],
      csharp: [/^\/\//, /^\/\*/, /^\*\//],
      go: [/^\/\//, /^\/\*/, /^\*\//],
      rust: [/^\/\//, /^\/\*/, /^\*\//],
      php: [/^\/\//, /^#/, /^\/\*/, /^\*\//],
      ruby: [/^#/],
      swift: [/^\/\//, /^\/\*/, /^\*\//],
      kotlin: [/^\/\//, /^\/\*/, /^\*\//],
      scala: [/^\/\//, /^\/\*/, /^\*\//],
      sql: [/^--/, /^\/\*/, /^\*\//],
      shell: [/^#/],
      html: [/^<!--/, /^-->$/],
      css: [/^\/\*/, /^\*\//],
      scss: [/^\/\*/, /^\*\//],
      sass: [/^\/\*/, /^\*\//],
      less: [/^\/\*/, /^\*\//],
      vue: [/^<!--/, /^-->$/, /^\/\//, /^\/\*/, /^\*\//],
      svelte: [/^<!--/, /^-->$/, /^\/\//, /^\/\*/, /^\*\//]
    };
    
    const patterns = commentPatterns[language] || commentPatterns.javascript;
    
    for (const pattern of patterns) {
      if (pattern.test(line)) {
        return true;
      }
    }
    
    return false;
  }

  /**
   * 更新选项
   */
  updateOptions(options: Partial<SmartIndexingOptions>): void {
    this.options = { ...this.options, ...options };
    this.logger.info('Updated smart indexing options', { options: this.options });
  }

  /**
   * 获取当前选项
   */
  getOptions(): SmartIndexingOptions {
    return { ...this.options };
  }
}