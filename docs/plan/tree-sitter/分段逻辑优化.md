åŸºäºæˆ‘å¯¹ä»£ç çš„æ·±å…¥åˆ†æï¼Œæˆ‘å·²ç»ç†è§£äº†tree-sitteråˆ†æ®µé—®é¢˜çš„æ ¹æœ¬åŸå› ã€‚ç°åœ¨è®©æˆ‘ä¸ºæ‚¨æä¾›ä¸€ä¸ªè¯¦ç»†çš„ä¼˜åŒ–æ–¹æ¡ˆã€‚

## ğŸ“‹ é—®é¢˜åˆ†æ

ä»æä¾›çš„ç¤ºä¾‹ä»£ç å¯ä»¥çœ‹å‡ºï¼Œå½“å‰çš„åˆ†æ®µé€»è¾‘å­˜åœ¨ç¬¦å·é—­åˆé—®é¢˜ï¼š

```javascript
return data.data.map((item: any) => {
  // ç¡®ä¿å‘é‡æ•°æ®æ˜¯çº¯æ•°å­—æ•°ç»„
  const embeddingArray = Array.isArray(item.embedding)
    ? item.embedding.map((val: any) => {
        // è½¬æ¢æ‰€æœ‰å€¼ä¸ºæ•°å­—ç±»å‹
        const num = Number(val);
        if (isNaN(num)) {
          this.logger.warn('Invalid embedding value found, replacing with 0', {
            originalValue: val,
            type: typeof val
          });
          return 0;
        }
        return num;
      })
```

**ä¸»è¦é—®é¢˜ï¼š**
1. åˆ†æ®µåœ¨ç®­å¤´å‡½æ•°ä¸­é—´æˆªæ–­ï¼Œå¯¼è‡´è¯­æ³•ä¸å®Œæ•´
2. æ‹¬å·å’ŒèŠ±æ‹¬å·æ²¡æœ‰æ­£ç¡®é—­åˆ
3. é‡å æœºåˆ¶å¯èƒ½ç ´åä»£ç ç»“æ„å®Œæ•´æ€§
4. æ²¡æœ‰è€ƒè™‘å¤šè¡Œè¡¨è¾¾å¼çš„è¯­æ³•å®Œæ•´æ€§

## ğŸ¯ ä¼˜åŒ–æ–¹æ¡ˆè®¾è®¡

### 1. ç¬¦å·å¹³è¡¡è·Ÿè¸ªæœºåˆ¶

```mermaid
graph TD
    A[å¼€å§‹åˆ†æ®µ] --> B[åˆå§‹åŒ–ç¬¦å·æ ˆ]
    B --> C{å¤„ç†ä¸‹ä¸€è¡Œ}
    C --> D[åˆ†æç¬¦å·å¹³è¡¡]
    D --> E{ç¬¦å·æ ˆä¸ºç©º?}
    E -->|æ˜¯| F[å¯ä»¥å®‰å…¨åˆ†æ®µ]
    E -->|å¦| G[ç»§ç»­ç´¯ç§¯]
    F --> H[ç”Ÿæˆåˆ†æ®µ]
    G --> C
    H --> C
```

### 2. æ”¹è¿›çš„åˆ†æ®µå†³ç­–é€»è¾‘

```typescript
interface SymbolStack {
  brackets: number;    // åœ†æ‹¬å· ()
  braces: number;      // èŠ±æ‹¬å· {}
  squares: number;     // æ–¹æ‹¬å· []
  templates: number;   // æ¨¡æ¿å­—ç¬¦ä¸² ``
}

class BalancedChunker {
  private symbolStack: SymbolStack = {
    brackets: 0,
    braces: 0,
    squares: 0,
    templates: 0
  };

  // åˆ†æè¡Œä¸­çš„ç¬¦å·å˜åŒ–
  analyzeLineSymbols(line: string): void {
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      const nextChar = line[i + 1];
      
      // å¤„ç†å„ç§ç¬¦å·
      switch (char) {
        case '(': this.symbolStack.brackets++; break;
        case ')': this.symbolStack.brackets--; break;
        case '{': this.symbolStack.braces++; break;
        case '}': this.symbolStack.braces--; break;
        case '[': this.symbolStack.squares++; break;
        case ']': this.symbolStack.squares--; break;
        case '`': 
          // å¤„ç†æ¨¡æ¿å­—ç¬¦ä¸²
          if (this.symbolStack.templates > 0) {
            this.symbolStack.templates--;
          } else {
            this.symbolStack.templates++;
          }
          break;
        case '/':
          // è·³è¿‡æ³¨é‡Š
          if (nextChar === '/' || nextChar === '*') {
            return; // è·³è¿‡æ•´è¡Œæ³¨é‡Š
          }
          break;
      }
    }
  }

  // æ£€æŸ¥æ˜¯å¦å¯ä»¥å®‰å…¨åˆ†æ®µ
  canSafelySplit(): boolean {
    return this.symbolStack.brackets === 0 &&
           this.symbolStack.braces === 0 &&
           this.symbolStack.squares === 0 &&
           this.symbolStack.templates === 0;
  }
}
```

### 3. æ™ºèƒ½é‡å è®¡ç®—

```typescript
private calculateSmartOverlap(
  currentChunk: string[], 
  originalCode: string,
  startLine: number
): string[] {
  const overlapLines: string[] = [];
  let overlapSize = 0;
  
  // ä»å½“å‰chunkæœ«å°¾å‘å‰å¯»æ‰¾å®‰å…¨çš„åˆ†å‰²ç‚¹
  for (let i = currentChunk.length - 1; i >= 0; i--) {
    const line = currentChunk[i];
    const tempStack = { ...this.symbolStack };
    
    // æ¨¡æ‹Ÿåˆ†æè¿™ä¸€è¡Œ
    this.analyzeLineSymbols(line);
    
    // å¦‚æœç¬¦å·å¹³è¡¡ï¼Œè¿™æ˜¯ä¸€ä¸ªå®‰å…¨çš„åˆ†å‰²ç‚¹
    if (this.canSafelySplit()) {
      overlapLines.unshift(...currentChunk.slice(i));
      break;
    } else {
      // æ¢å¤ç¬¦å·æ ˆçŠ¶æ€
      this.symbolStack = tempStack;
    }
  }
  
  return overlapLines;
}
```

### 4. è¯­æ³•éªŒè¯æ­¥éª¤

```typescript
private validateChunkSyntax(chunkContent: string, language: string): boolean {
  try {
    // å¯¹äºJavaScript/TypeScriptï¼Œä½¿ç”¨acornæˆ–å…¶ä»–è§£æå™¨éªŒè¯è¯­æ³•
    if (language === 'javascript' || language === 'typescript') {
      // ç®€å•çš„è¯­æ³•æ£€æŸ¥ - ç¡®ä¿æ‹¬å·å¹³è¡¡
      const bracketBalance = this.checkBracketBalance(chunkContent);
      const braceBalance = this.checkBraceBalance(chunkContent);
      
      return bracketBalance === 0 && braceBalance === 0;
    }
    
    return true; // å¯¹äºå…¶ä»–è¯­è¨€ï¼Œæš‚æ—¶è¿”å›true
  } catch (error) {
    this.logger?.warn(`Syntax validation failed: ${error}`);
    return false;
  }
}

private checkBracketBalance(content: string): number {
  let balance = 0;
  for (const char of content) {
    if (char === '(') balance++;
    if (char === ')') balance--;
  }
  return balance;
}

private checkBraceBalance(content: string): number {
  let balance = 0;
  for (const char of content) {
    if (char === '{') balance++;
    if (char === '}') balance--;
  }
  return balance;
}
```

## ğŸš€ å…·ä½“å®ç°å»ºè®®

### ä¿®æ”¹ASTCodeSplitterçš„createIntelligentChunksæ–¹æ³•ï¼š

```typescript
private createIntelligentChunks(
  content: string,
  language: string,
  filePath?: string
): CodeChunk[] {
  const chunks: CodeChunk[] = [];
  const lines = content.split('\n');
  let currentChunk: string[] = [];
  let currentLine = 1;
  let currentSize = 0;
  
  const symbolTracker = new BalancedChunker();

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const lineSize = line.length + 1;

    // æ›´æ–°ç¬¦å·è·Ÿè¸ª
    symbolTracker.analyzeLineSymbols(line);

    // æ£€æŸ¥æ˜¯å¦éœ€è¦åœ¨é€»è¾‘è¾¹ç•Œå¤„åˆ†æ®µ
    const shouldSplit = this.shouldSplitAtLineWithSymbols(
      line, 
      currentChunk, 
      currentSize, 
      lineSize,
      symbolTracker
    );
    
    if (shouldSplit && currentChunk.length > 0) {
      const chunkContent = currentChunk.join('\n');
      
      // éªŒè¯åˆ†æ®µè¯­æ³•
      if (this.validateChunkSyntax(chunkContent, language)) {
        const complexity = this.calculateComplexity(chunkContent);
        
        const metadata: CodeChunkMetadata = {
          startLine: currentLine,
          endLine: currentLine + currentChunk.length - 1,
          language,
          filePath,
          type: 'generic',
          complexity
        };

        chunks.push({
          content: chunkContent,
          metadata
        });
      }

      // åº”ç”¨æ™ºèƒ½é‡å 
      const overlapLines = this.calculateSmartOverlap(
        currentChunk, 
        content, 
        currentLine
      );
      currentChunk = overlapLines;
      currentLine = i - overlapLines.length + 1;
      currentSize = overlapLines.join('\n').length;
    }

    currentChunk.push(line);
    currentSize += lineSize;
  }

  // å¤„ç†æœ€åçš„chunkï¼ˆçœç•¥ï¼‰
  return chunks;
}
```

### æ”¹è¿›çš„shouldSplitAtLineæ–¹æ³•ï¼š

```typescript
private shouldSplitAtLineWithSymbols(
  line: string,
  currentChunk: string[],
  currentSize: number,
  lineSize: number,
  symbolTracker: BalancedChunker
): boolean {
  // å¤§å°é™åˆ¶æ£€æŸ¥ï¼ˆä¼˜å…ˆï¼‰
  if (currentSize + lineSize > this.options.maxChunkSize) {
    return true;
  }

  // ç¬¦å·å¹³è¡¡æ£€æŸ¥ - åªæœ‰åœ¨ç¬¦å·å¹³è¡¡æ—¶æ‰å…è®¸åˆ†æ®µ
  if (!symbolTracker.canSafelySplit()) {
    return false;
  }

  const trimmedLine = line.trim();
  
  // é€»è¾‘è¾¹ç•Œæ£€æŸ¥ï¼ˆåŸæœ‰çš„é€»è¾‘ï¼‰
  if (trimmedLine.match(/^[}\)]\s*$/) && currentChunk.length > 0) {
    return currentSize > this.options.maxChunkSize * 0.3;
  }

  if (trimmedLine.match(/^\s*(}|\)|\]|;)\s*$/)) {
    return currentSize > this.options.maxChunkSize * 0.5;
  }

  if (trimmedLine === '' && currentChunk.length > 5) {
    return currentSize > this.options.maxChunkSize * 0.4;
  }

  if (trimmedLine.match(/^\s*\/\//) || trimmedLine.match(/^\s*\/\*/) || trimmedLine.match(/^\s*\*/)) {
    return currentSize > this.options.maxChunkSize * 0.6;
  }

  return false;
}
```

## ğŸ“Š æ€§èƒ½è€ƒè™‘

1. **ç¬¦å·è·Ÿè¸ªå¼€é”€**ï¼šç¬¦å·åˆ†ææ˜¯O(n)å¤æ‚åº¦ï¼Œå¯¹æ€§èƒ½å½±å“æœ‰é™
2. **ç¼“å­˜æœºåˆ¶**ï¼šå¯ä»¥ç¼“å­˜ç¬¦å·åˆ†æç»“æœï¼Œé¿å…é‡å¤è®¡ç®—
3. **å¢é‡åˆ†æ**ï¼šé€è¡Œåˆ†æï¼Œé¿å…ä¸€æ¬¡æ€§å¤„ç†æ•´ä¸ªæ–‡ä»¶

æˆ‘éœ€è¦ä¸ºæ€§èƒ½ä¼˜åŒ–éƒ¨åˆ†æä¾›æ›´å…·ä½“çš„å®ç°æ–¹æ¡ˆã€‚è®©æˆ‘è¯¦ç»†è®¾è®¡æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼š

**ğŸ“Š æ€§èƒ½ä¼˜åŒ–å…·ä½“æ–¹æ¡ˆ**

### 1. ç¬¦å·è·Ÿè¸ªå¼€é”€ä¼˜åŒ–

```typescript
class OptimizedSymbolTracker {
  private symbolStack: SymbolStack = { brackets: 0, braces: 0, squares: 0, templates: 0 };
  private lineHashes: Map<number, string> = new Map(); // è¡Œå· -> ç¬¦å·çŠ¶æ€å“ˆå¸Œ
  private analysisCache: Map<string, SymbolStack> = new Map(); // è¡Œå†…å®¹ -> ç¬¦å·å˜åŒ–

  analyzeLineSymbols(line: string, lineNumber: number): void {
    const lineHash = this.simpleHash(line);
    
    // æ£€æŸ¥ç¼“å­˜
    if (this.analysisCache.has(lineHash)) {
      const cachedChange = this.analysisCache.get(lineHash)!;
      this.applySymbolChange(cachedChange);
      this.lineHashes.set(lineNumber, lineHash);
      return;
    }

    // é¦–æ¬¡åˆ†æå¹¶ç¼“å­˜
    const originalState = { ...this.symbolStack };
    this.analyzeLineSymbolsInternal(line);
    const symbolChange = this.calculateSymbolChange(originalState, this.symbolStack);
    this.analysisCache.set(lineHash, symbolChange);
    this.lineHashes.set(lineNumber, lineHash);
  }

  private analyzeLineSymbolsInternal(line: string): void {
    // ä½¿ç”¨æ›´é«˜æ•ˆçš„å­—ç¬¦æ‰«æç®—æ³•
    let inSingleComment = false;
    let inMultiComment = false;
    let inString = false;
    let stringChar = '';

    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      const nextChar = line[i + 1];

      // è·³è¿‡æ³¨é‡Šå’Œå­—ç¬¦ä¸²å†…å®¹
      if (inSingleComment) continue;
      if (inMultiComment) {
        if (char === '*' && nextChar === '/') {
          inMultiComment = false;
          i++; // è·³è¿‡'*/'
        }
        continue;
      }
      if (inString) {
        if (char === stringChar && line[i - 1] !== '\\') {
          inString = false;
        }
        continue;
      }

      // å¤„ç†ç¬¦å·
      switch (char) {
        case '/':
          if (nextChar === '/') inSingleComment = true;
          if (nextChar === '*') inMultiComment = true;
          break;
        case '"': case "'": case '`':
          inString = true;
          stringChar = char;
          if (char === '`') this.symbolStack.templates++;
          break;
        case '(': this.symbolStack.brackets++; break;
        case ')': this.symbolStack.brackets--; break;
        case '{': this.symbolStack.braces++; break;
        case '}': this.symbolStack.braces--; break;
        case '[': this.symbolStack.squares++; break;
        case ']': this.symbolStack.squares--; break;
      }
    }
  }
}
```

### 2. ç¼“å­˜æœºåˆ¶å®ç°

```typescript
class SymbolAnalysisCache {
  private static readonly MAX_CACHE_SIZE = 1000;
  private cache: Map<string, SymbolStackChange> = new Map();
  private accessOrder: string[] = [];

  get(lineHash: string): SymbolStackChange | undefined {
    const result = this.cache.get(lineHash);
    if (result) {
      // æ›´æ–°è®¿é—®é¡ºåºï¼ˆLRUï¼‰
      this.accessOrder = this.accessOrder.filter(hash => hash !== lineHash);
      this.accessOrder.push(lineHash);
    }
    return result;
  }

  set(lineHash: string, change: SymbolStackChange): void {
    if (this.cache.size >= SymbolAnalysisCache.MAX_CACHE_SIZE) {
      // ç§»é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ¡ç›®
      const oldestHash = this.accessOrder.shift();
      if (oldestHash) {
        this.cache.delete(oldestHash);
      }
    }
    
    this.cache.set(lineHash, change);
    this.accessOrder.push(lineHash);
  }

  // æ‰¹é‡é¢„ç¼“å­˜å¸¸è§ä»£ç æ¨¡å¼
  preCacheCommonPatterns(): void {
    const commonPatterns = [
      'function () {}',
      'if () {}',
      'for () {}',
      'while () {}',
      'try {} catch {}',
      'class {}',
      '[]',
      '{}'
    ];

    commonPatterns.forEach(pattern => {
      const tracker = new OptimizedSymbolTracker();
      tracker.analyzeLineSymbols(pattern, 0);
      // ç¼“å­˜ç»“æœ...
    });
  }
}
```

### 3. å¢é‡åˆ†æä¼˜åŒ–

```typescript
class IncrementalSymbolAnalysis {
  private currentState: SymbolStack = { brackets: 0, braces: 0, squares: 0, templates: 0 };
  private stateHistory: Map<number, SymbolStack> = new Map(); // è¡Œå· -> ç¬¦å·çŠ¶æ€

  // å¢é‡åˆ†æä»æŒ‡å®šè¡Œå¼€å§‹
  analyzeFromLine(lines: string[], startLine: number): void {
    // å¦‚æœæœ‰å†å²çŠ¶æ€ï¼Œä»é‚£é‡Œæ¢å¤
    if (this.stateHistory.has(startLine - 1)) {
      this.currentState = { ...this.stateHistory.get(startLine - 1)! };
    }

    for (let i = startLine; i < lines.length; i++) {
      this.analyzeLine(lines[i]);
      this.stateHistory.set(i, { ...this.currentState });
      
      // å®šæœŸæ¸…ç†å†å²ï¼Œé¿å…å†…å­˜å ç”¨è¿‡å¤§
      if (i % 100 === 0) {
        this.cleanupOldHistory(i - 200);
      }
    }
  }

  private cleanupOldHistory(threshold: number): void {
    for (const [lineNumber] of this.stateHistory) {
      if (lineNumber < threshold) {
        this.stateHistory.delete(lineNumber);
      }
    }
  }

  // æ”¯æŒå›æ»šåˆ°ç‰¹å®šè¡Œçš„çŠ¶æ€
  rollbackToLine(lineNumber: number): void {
    if (this.stateHistory.has(lineNumber)) {
      this.currentState = { ...this.stateHistory.get(lineNumber)! };
    }
  }
}
```

### 4. æ€§èƒ½ç›‘æ§å’Œè°ƒä¼˜
éœ€è¦é›†æˆåˆ°ç°æœ‰ç›‘æ§ç³»ç»Ÿä¸­ï¼Œä¸”å¤„ç†é€»è¾‘ä¸å…¶ä»–ç›‘æ§æ¨¡å—å¯¹é½
```typescript
class PerformanceMonitor {
  private static readonly SAMPLE_INTERVAL = 1000; // æ¯1000è¡Œé‡‡æ ·ä¸€æ¬¡
  private metrics = {
    totalLines: 0,
    cacheHits: 0,
    cacheMisses: 0,
    analysisTime: 0,
    memoryUsage: 0
  };

  recordAnalysis(startTime: number, linesProcessed: number, cacheHit: boolean): void {
    this.metrics.totalLines += linesProcessed;
    if (cacheHit) this.metrics.cacheHits++;
    else this.metrics.cacheMisses++;
    
    this.metrics.analysisTime += Date.now() - startTime;

    // å®šæœŸè¾“å‡ºæ€§èƒ½æŠ¥å‘Š
    if (this.metrics.totalLines % PerformanceMonitor.SAMPLE_INTERVAL === 0) {
      this.logPerformance();
    }
  }

  private logPerformance(): void {
    const cacheHitRate = this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) || 0;
    const avgTimePerLine = this.metrics.analysisTime / this.metrics.totalLines;
    
    console.log(`æ€§èƒ½æŠ¥å‘Š:
      - å¤„ç†è¡Œæ•°: ${this.metrics.totalLines}
      - ç¼“å­˜å‘½ä¸­ç‡: ${(cacheHitRate * 100).toFixed(2)}%
      - å¹³å‡æ¯è¡Œåˆ†ææ—¶é—´: ${avgTimePerLine.toFixed(3)}ms
      - æ€»åˆ†ææ—¶é—´: ${this.metrics.analysisTime}ms`);
  }

  // å†…å­˜ä½¿ç”¨ç›‘æ§
  monitorMemoryUsage(): void {
    setInterval(() => {
      const memoryUsage = process.memoryUsage();
      this.metrics.memoryUsage = memoryUsage.heapUsed / 1024 / 1024; // MB
      
      if (this.metrics.memoryUsage > 500) { // 500MBé˜ˆå€¼
        console.warn('é«˜å†…å­˜ä½¿ç”¨è­¦å‘Šï¼Œè€ƒè™‘æ¸…ç†ç¼“å­˜');
        SymbolAnalysisCache.getInstance().clear();
      }
    }, 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
  }
}
```

### 5. è‡ªé€‚åº”æ€§èƒ½ç­–ç•¥

```typescript
class AdaptivePerformanceStrategy {
  private static complexityThresholds = {
    low: 50,    // ç®€å•æ–‡ä»¶
    medium: 200, // ä¸­ç­‰å¤æ‚åº¦
    high: 500    // é«˜å¤æ‚åº¦
  };

  static getOptimizationLevel(content: string): 'low' | 'medium' | 'high' {
    const lines = content.split('\n').length;
    const complexity = this.estimateComplexity(content);

    if (lines < 100 && complexity < this.complexityThresholds.low) {
      return 'low'; // ä½¿ç”¨åŸºæœ¬ç¬¦å·è·Ÿè¸ª
    } else if (lines < 1000 && complexity < this.complexityThresholds.medium) {
      return 'medium'; // ä½¿ç”¨ç¼“å­˜ä¼˜åŒ–
    } else {
      return 'high'; // ä½¿ç”¨å®Œæ•´ä¼˜åŒ–ç­–ç•¥
    }
  }

  private static estimateComplexity(content: string): number {
    // å¿«é€Ÿå¤æ‚åº¦ä¼°ç®—
    let score = 0;
    score += (content.match(/\b(function|class|interface)\b/g) || []).length * 10;
    score += (content.match(/\b(if|else|for|while|switch)\b/g) || []).length * 5;
    score += (content.match(/[{}()[\]]/g) || []).length;
    return score;
  }
}

// åœ¨ASTCodeSplitterä¸­ä½¿ç”¨
private createIntelligentChunks(content: string, language: string, filePath?: string): CodeChunk[] {
  const optimizationLevel = AdaptivePerformanceStrategy.getOptimizationLevel(content);
  
  switch (optimizationLevel) {
    case 'low':
      return this.createChunksWithBasicTracking(content, language, filePath);
    case 'medium':
      return this.createChunksWithCachedTracking(content, language, filePath);
    case 'high':
      return this.createChunksWithFullOptimization(content, language, filePath);
  }
}
```


## ğŸ”§ å®æ–½æ­¥éª¤

1. é¦–å…ˆå®ç°`BalancedChunker`ç±»æ¥å¤„ç†ç¬¦å·å¹³è¡¡è·Ÿè¸ª
2. ä¿®æ”¹`createIntelligentChunks`æ–¹æ³•ä½¿ç”¨æ–°çš„ç¬¦å·è·Ÿè¸ªæœºåˆ¶
3. å®ç°`shouldSplitAtLineWithSymbols`æ›¿ä»£åŸæœ‰çš„ç®€å•é€»è¾‘
4. æ·»åŠ è¯­æ³•éªŒè¯æ­¥éª¤ç¡®ä¿åˆ†æ®µè´¨é‡
5. æµ‹è¯•å„ç§è¾¹ç•Œæƒ…å†µï¼Œç‰¹åˆ«æ˜¯åµŒå¥—ç»“æ„

è¿™ä¸ªä¼˜åŒ–æ–¹æ¡ˆå°†æ˜¾è‘—æ”¹å–„åˆ†æ®µè´¨é‡ï¼Œç¡®ä¿ä»£ç ç‰‡æ®µè¯­æ³•å®Œæ•´ï¼Œç¬¦å·æ­£ç¡®é—­åˆã€‚