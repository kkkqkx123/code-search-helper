根据对代码库的深入分析，我将从块边界选择和块重叠处理两个核心维度来评估分段逻辑的设计，并提出具体的改进建议。

## 一、当前分段逻辑分析

### 1. 块边界选择机制

**优点：**
- 多层次回退策略（SyntaxAware → Intelligent → Semantic）提供了良好的容错性
- BalancedChunker 实现了符号平衡检查，避免在代码结构中间断开
- 考虑了注释、字符串中的符号，避免误判

**存在问题：**

1. **边界选择过于简单**
```typescript
// IntelligentSplitterOptimizer.ts 中的分割条件
if (trimmedLine.match(/^[}\)]\s*$/) && currentChunk.length > 0) {
  return currentSize > maxChunkSize * 0.3;
}
```
这种基于正则表达式的边界检测过于粗糙，没有考虑语义完整性。

2. **缺乏语义边界的深度分析**
当前只停留在语法层面，没有考虑函数、类、模块等语义边界的重要性。

### 2. 块重叠处理逻辑

**优点：**
- 实现了智能重叠计算，考虑符号平衡
- 避免在重叠中破坏代码结构

**存在问题：**

1. **重叠策略不一致**
```typescript
// IntelligentSplitter.ts 中的重叠计算
const overlapLines = this.optimizer.calculateSmartOverlap(
  currentChunk,
  content,
  this.options.overlapSize
);

// OverlapCalculator.ts 中的不同实现
calculateSmartOverlap(currentChunk: string[], originalCode: string, startLine: number)
```
两个不同的重叠计算方法可能导致不一致的结果。

2. **重叠内容选择不够智能**
当前主要基于字符数量选择重叠，没有考虑重叠内容的语义价值。

## 二、具体改进建议

### 1. 块边界选择的改进

#### 1.1 引入语义边界评分机制

```typescript
// 新增：SemanticBoundaryAnalyzer.ts
export class SemanticBoundaryAnalyzer {
  /**
   * 计算行作为分割边界的合适度
   * 返回 0-1 的分数，越高越适合作为边界
   */
  calculateBoundaryScore(line: string, context: string[]): number {
    let score = 0;
  
    // 基础语法完整性检查
    if (this.isSyntacticallySafe(line)) {
      score += 0.3;
    }
  
    // 语义边界检查
    if (this.isFunctionEnd(line)) score += 0.4;
    if (this.isClassEnd(line)) score += 0.4;
    if (this.isMethodEnd(line)) score += 0.35;
    if (this.isImportEnd(line)) score += 0.2;
  
    // 逻辑分组检查
    if (this.isEmptyLine(line) && this.hasLogicalSeparation(context)) {
      score += 0.25;
    }
  
    // 注释边界检查
    if (this.isCommentBlockEnd(line)) score += 0.15;
  
    return Math.min(score, 1.0);
  }

  private isSyntacticallySafe(line: string): boolean {
    // 检查行是否在符号平衡的位置
    const trimmed = line.trim();
    return trimmed.endsWith('}') || 
           trimmed.endsWith(')') || 
           trimmed.endsWith(';') ||
           trimmed === '';
  }

  private isFunctionEnd(line: string): boolean {
    return /^\s*}\s*$/.test(line) || 
           /^\s*}\s*\/\/.*$/.test(line) ||
           /^\s*}\s*\/\*.*\*\/\s*$/.test(line);
  }

  // ... 其他边界检测方法
}
```

#### 1.2 改进 BalancedChunker 的边界决策

```typescript
// BalancedChunker.ts 改进
export class BalancedChunker {
  private semanticAnalyzer: SemanticBoundaryAnalyzer;

  /**
   * 智能边界选择，结合符号平衡和语义分析
   */
  findOptimalBoundary(lines: string[], startPos: number, maxEndPos: number): number {
    let bestBoundary = startPos;
    let bestScore = 0;
  
    // 从期望的结束位置向前搜索最佳边界
    for (let i = Math.min(maxEndPos, lines.length - 1); i >= startPos; i--) {
      this.analyzeLineSymbols(lines[i]);
    
      if (!this.canSafelySplit()) continue;
    
      // 计算该位置作为边界的综合评分
      const contextLines = lines.slice(Math.max(0, i - 2), i + 1);
      const boundaryScore = this.semanticAnalyzer.calculateBoundaryScore(
        lines[i], 
        contextLines
      );
    
      // 考虑距离理想位置的程度
      const distancePenalty = Math.abs(i - maxEndPos) / lines.length;
      const finalScore = boundaryScore - distancePenalty * 0.3;
    
      if (finalScore > bestScore) {
        bestScore = finalScore;
        bestBoundary = i;
      }
    
      // 如果找到足够好的边界，提前结束搜索
      if (bestScore > 0.8) break;
    }
  
    return bestBoundary;
  }
}
```

### 2. 块重叠处理的改进

#### 2.1 统一重叠计算策略

```typescript
// 新增：UnifiedOverlapCalculator.ts
export class UnifiedOverlapCalculator {
  private semanticAnalyzer: SemanticBoundaryAnalyzer;
  private balancedChunker: BalancedChunker;

  /**
   * 统一的重叠计算方法
   */
  calculateOptimalOverlap(
    currentChunk: CodeChunk,
    nextChunk: CodeChunk,
    originalCode: string,
    options: OverlapOptions
  ): OverlapResult {
    const strategy = this.selectOverlapStrategy(currentChunk, nextChunk);
  
    switch (strategy) {
      case 'semantic':
        return this.calculateSemanticOverlap(currentChunk, nextChunk, originalCode, options);
      case 'syntactic':
        return this.calculateSyntacticOverlap(currentChunk, nextChunk, originalCode, options);
      case 'size-based':
        return this.calculateSizeBasedOverlap(currentChunk, nextChunk, options);
      default:
        return this.calculateHybridOverlap(currentChunk, nextChunk, originalCode, options);
    }
  }

  private selectOverlapStrategy(currentChunk: CodeChunk, nextChunk: CodeChunk): OverlapStrategy {
    // 根据块类型和内容选择最适合的重叠策略
    if (currentChunk.metadata.type === 'function' && nextChunk.metadata.type === 'function') {
      return 'semantic';
    }
    if (currentChunk.metadata.complexity && currentChunk.metadata.complexity > 10) {
      return 'syntactic';
    }
    return 'hybrid';
  }

  private calculateSemanticOverlap(
    currentChunk: CodeChunk,
    nextChunk: CodeChunk,
    originalCode: string,
    options: OverlapOptions
  ): OverlapResult {
    // 优先包含语义重要的重叠内容
    const overlapLines: string[] = [];
    const lines = originalCode.split('\n');
  
    // 从当前块末尾向前搜索，优先选择语义边界
    for (let i = currentChunk.metadata.endLine - 1; i >= currentChunk.metadata.startLine - 1; i--) {
      if (overlapLines.join('\n').length >= options.maxSize) break;
    
      const line = lines[i];
      const boundaryScore = this.semanticAnalyzer.calculateBoundaryScore(line, []);
    
      // 高评分的边界更有可能被包含在重叠中
      if (boundaryScore > 0.6 || overlapLines.length < options.minLines) {
        overlapLines.unshift(line);
      }
    }
  
    return {
      content: overlapLines.join('\n'),
      lines: overlapLines.length,
      strategy: 'semantic'
    };
  }
}
```

#### 2.2 上下文感知的重叠优化

```typescript
// 新增：ContextAwareOverlapOptimizer.ts
export class ContextAwareOverlapOptimizer {
  /**
   * 根据上下文优化重叠内容
   */
  optimizeOverlapForContext(
    overlap: OverlapResult,
    currentChunk: CodeChunk,
    nextChunk: CodeChunk
  ): OverlapResult {
    // 分析当前块和下一块的关系
    const relationship = this.analyzeChunkRelationship(currentChunk, nextChunk);
  
    switch (relationship.type) {
      case 'sequential_functions':
        return this.optimizeForSequentialFunctions(overlap, currentChunk, nextChunk);
      case 'class_methods':
        return this.optimizeForClassMethods(overlap, currentChunk, nextChunk);
      case 'related_imports':
        return this.optimizeForRelatedImports(overlap, currentChunk, nextChunk);
      default:
        return overlap;
    }
  }

  private optimizeForSequentialFunctions(
    overlap: OverlapResult,
    currentChunk: CodeChunk,
    nextChunk: CodeChunk
  ): OverlapResult {
    // 对于连续的函数，确保包含函数间的注释或空行
    const lines = overlap.content.split('\n');
    const optimizedLines = [];
  
    for (let i = 0; i < lines.length; i++) {
      optimizedLines.push(lines[i]);
    
      // 在函数结束处添加后续的注释或空行
      if (this.isFunctionEnd(lines[i]) && i < lines.length - 1) {
        const nextLine = lines[i + 1];
        if (this.isCommentOrEmpty(nextLine)) {
          optimizedLines.push(nextLine);
          i++; // 跳过下一行，因为已经包含
        }
      }
    }
  
    return {
      ...overlap,
      content: optimizedLines.join('\n'),
      lines: optimizedLines.length
    };
  }
}
```

### 3. 配置和参数优化

#### 3.1 动态参数调整

```typescript
// types/index.ts 改进
export interface AdaptiveChunkingOptions extends ChunkingOptions {
  // 动态调整参数
  adaptiveBoundaryThreshold?: boolean;
  contextAwareOverlap?: boolean;
  semanticWeight?: number;
  syntacticWeight?: number;

  // 针对不同代码类型的专门配置
  functionSpecificOptions?: {
    preferWholeFunctions: boolean;
    minFunctionOverlap: number;
  };

  classSpecificOptions?: {
    keepMethodsTogether: boolean;
    classHeaderOverlap: number;
  };
}
```

#### 3.2 性能优化建议

```typescript
// 新增：ChunkingPerformanceOptimizer.ts
export class ChunkingPerformanceOptimizer {
  private analysisCache: Map<string, AnalysisResult> = new Map();

  /**
   * 缓存边界分析结果以提高性能
   */
  getCachedBoundaryAnalysis(lineHash: string): AnalysisResult | null {
    return this.analysisCache.get(lineHash) || null;
  }

  /**
   * 批量预分析以提高大文件处理速度
   */
  async preAnalyzeFile(content: string): Promise<PreAnalysisResult> {
    const lines = content.split('\n');
    const boundaryCandidates = [];
  
    // 并行分析多行
    const batchSize = 100;
    for (let i = 0; i < lines.length; i += batchSize) {
      const batch = lines.slice(i, i + batchSize);
      const batchResults = await Promise.all(
        batch.map(line => this.analyzeLineAsync(line))
      );
    
      boundaryCandidates.push(...batchResults.map((result, index) => ({
        line: i + index,
        score: result.boundaryScore,
        properties: result.properties
      })));
    }
  
    return {
      boundaryCandidates,
      estimatedComplexity: this.calculateOverallComplexity(boundaryCandidates)
    };
  }
}
```

## 三、测试用例改进建议

当前测试用例需要增加更多边界情况的覆盖：

```typescript
// __tests__/boundary-selection.test.ts
describe('Enhanced Boundary Selection', () => {
  it('should prefer semantic boundaries over size-based boundaries', async () => {
    const code = `
      function utilityFunction() {
        return 'utility';
      }
    
      // Main processing function
      function processData(data) {
        return data.map(item => {
          return item + '_processed';
        });
      }
    
      // Export section
      export { utilityFunction, processData };
    `;
  
    const chunks = await splitter.split(code, 'typescript');
  
    // 验证分割发生在语义边界而不是任意位置
    expect(chunks).toHaveLength(2);
    expect(chunks[0].content).toContain('function utilityFunction');
    expect(chunks[1].content).toContain('function processData');
  });

  it('should handle nested structures with proper overlap', async () => {
    const code = `
      class OuterClass {
        innerMethod() {
          if (condition) {
            return {
              nested: {
                value: true
              }
            };
          }
        }
      
        anotherMethod() {
          return this.innerMethod();
        }
      }
    `;
  
    const chunks = await splitter.split(code, 'typescript');
  
    if (chunks.length > 1) {
      // 验证重叠保持了结构完整性
      const overlap = chunks[0].content.slice(-100);
      expect(() => JSON.parse(overlap)).not.toThrow();
    }
  });
});
```

## 四、总结

主要改进方向：

1. **块边界选择**：从简单的语法检查升级为语义感知的边界评分系统
2. **块重叠处理**：统一重叠计算策略，引入上下文感知优化
3. **性能优化**：增加缓存机制和批量预分析
4. **配置灵活性**：支持针对不同代码类型的专门配置

这些改进将显著提高代码分段的准确性和语义完整性，同时保持良好的性能表现。