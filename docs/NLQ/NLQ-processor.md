## 1. 自然语言查询处理器

### 1.1 意图识别功能
**实现目标**: 识别自然语言查询的意图和类型

**实现方案1 - 基于规则的模式匹配**:
- 使用正则表达式匹配常见查询模式
- 优点：实现简单，响应快速
- 缺点：灵活性有限，需要维护大量规则

**实现方案2 - 机器学习分类器**:
- 训练BERT或类似模型进行意图分类
- 优点：准确率高，泛化能力强
- 缺点：需要标注数据，训练成本高

**实现方案3 - 混合方法**:
- 规则匹配处理常见查询，ML处理复杂查询
- 优点：平衡性能和灵活性
- 推荐：初期采用方案1，逐步过渡到方案3

### 1.2 参数提取和约束解析
**实现目标**: 从自然语言中提取查询参数和约束条件

**实现方案1 - 命名实体识别(NER)**:
- 使用spaCy或类似工具提取代码相关实体
- 支持提取：文件名、函数名、变量名、语言类型等
- 配置实体类型：`FILE`, `FUNCTION`, `VARIABLE`, `LANGUAGE`, `PATTERN`

**实现方案2 - 依赖解析**:
- 分析句子结构识别约束关系
- 识别：包含/排除条件、过滤条件、排序要求

### 1.3 查询重构和优化
**实现目标**: 将自然语言转换为结构化查询并优化

**实现方案1 - 模板化转换**:
- 预定义查询模板库
- 根据意图选择合适模板填充参数
- 模板示例：`搜索包含{pattern}的{language}文件`

**实现方案2 - AST生成**:
- 构建查询抽象语法树
- 支持复杂查询的组合和嵌套
- 便于后续优化和转换

**实现方案3 - 查询优化器**:
- 基于代价的查询优化
- 考虑：索引可用性、数据分布、性能约束
- 动态调整查询执行计划

### 1.4 多步骤查询分解
**实现目标**: 处理需要多步骤执行的复杂查询

**实现方案1 - 查询计划生成**:
- 分析查询依赖关系
- 生成执行计划DAG（有向无环图）
- 支持并行和顺序执行

**实现方案2 - 中间结果管理**:
- 缓存中间查询结果
- 支持结果重用在后续步骤中
- 实现结果引用机制（如`$result1`）

**实现方案3 - 进度跟踪和状态管理**:
- 跟踪多步骤查询执行进度
- 提供执行状态查询接口
- 支持查询暂停、恢复、取消