{
  "metadata": {
    "totalFiles": 46,
    "successfulFiles": 46,
    "generatedAt": "2025-11-18T16:13:48.146Z"
  },
  "parsedFiles": [
    {
      "file": "concurrency\\c-1-线程创建并发关系.md",
      "testCase": "#include <pthread.h>\n#include <windows.h>\n\nvoid* thread_function(void* arg) {\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    pthread_attr_t attr;\n    \n    // pthread_create测试\n    pthread_create(&thread, &attr, thread_function, NULL);\n    \n    // CreateThread测试\n    HANDLE hThread = CreateThread(\n        NULL,                   // Security attributes\n        0,                      // Stack size\n        (LPTHREAD_START_ROUTINE)thread_function,  // Start function\n        NULL,                   // Argument\n        0,                      // Creation flags\n        NULL                    // Thread ID\n    );\n    \n    // _beginthreadex测试\n    HANDLE hThread2 = (HANDLE)_beginthreadex(\n        NULL,                   // Security\n        0,                      // Stack size\n        (LPTHREAD_START_ROUTINE)thread_function,  // Start function\n        NULL,                   // Argument\n        0,                      // Init flag\n        NULL                    // Thread address\n    );\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.thread.creation\n  function: (identifier) @thread.create.function\n  (#match? @thread.create.function \"^(pthread_create|CreateThread|_beginthreadex)$\")\n  arguments: (argument_list\n    (identifier) @thread.handle\n    (identifier) @thread.attributes\n    (identifier) @thread.start.function\n    (identifier) @thread.argument)"
    },
    {
      "file": "concurrency\\c-10-互斥锁销毁同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    \n    pthread_mutex_init(&mutex, NULL);\n    pthread_mutex_lock(&mutex);\n    pthread_mutex_unlock(&mutex);\n    \n    // pthread_mutex_destroy测试\n    pthread_mutex_destroy(&mutex);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.mutex.destroy\n  function: (identifier) @mutex.destroy.function\n  (#match? @mutex.destroy.function \"^(pthread_mutex_destroy)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle))"
    },
    {
      "file": "concurrency\\c-11-条件变量初始化同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_cond_t cond;\n    pthread_condattr_t attr;\n    \n    // pthread_cond_init测试\n    pthread_cond_init(&cond, &attr);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.condition.init\n  function: (identifier) @cond.init.function\n  (#match? @cond.init.function \"^(pthread_cond_init)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle)\n    (identifier)? @cond.attributes)"
    },
    {
      "file": "concurrency\\c-12-条件变量等待同步关系.md",
      "testCase": "#include <pthread.h>\n#include <time.h>\n\nint main() {\n    pthread_cond_t cond;\n    pthread_mutex_t mutex;\n    \n    pthread_cond_init(&cond, NULL);\n    pthread_mutex_init(&mutex, NULL);\n    \n    pthread_mutex_lock(&mutex);\n    \n    // pthread_cond_wait测试\n    pthread_cond_wait(&cond, &mutex);\n    \n    // pthread_cond_timedwait测试\n    struct timespec timeout;\n    clock_gettime(CLOCK_REALTIME, &timeout);\n    timeout.tv_sec += 5; // 5秒后超时\n    pthread_cond_timedwait(&cond, &mutex, &timeout);\n    \n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.condition.wait\n  function: (identifier) @cond.wait.function\n  (#match? @cond.wait.function \"^(pthread_cond_wait|pthread_cond_timedwait)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle)\n    (pointer_expression argument: (identifier) @mutex.handle))"
    },
    {
      "file": "concurrency\\c-13-条件变量信号同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_cond_t cond;\n    pthread_mutex_t mutex;\n    \n    pthread_cond_init(&cond, NULL);\n    pthread_mutex_init(&mutex, NULL);\n    \n    pthread_mutex_lock(&mutex);\n    \n    // pthread_cond_signal测试\n    pthread_cond_signal(&cond);\n    \n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.condition.signal\n  function: (identifier) @cond.signal.function\n  (#match? @cond.signal.function \"^(pthread_cond_signal)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle))"
    },
    {
      "file": "concurrency\\c-14-条件变量广播同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_cond_t cond;\n    pthread_mutex_t mutex;\n    \n    pthread_cond_init(&cond, NULL);\n    pthread_mutex_init(&mutex, NULL);\n    \n    pthread_mutex_lock(&mutex);\n    \n    // pthread_cond_broadcast测试\n    pthread_cond_broadcast(&cond);\n    \n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.condition.broadcast\n  function: (identifier) @cond.broadcast.function\n  (#match? @cond.broadcast.function \"^(pthread_cond_broadcast)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle))"
    },
    {
      "file": "concurrency\\c-15-条件变量销毁同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_cond_t cond;\n    \n    pthread_cond_init(&cond, NULL);\n    \n    // pthread_cond_destroy测试\n    pthread_cond_destroy(&cond);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.condition.destroy\n  function: (identifier) @cond.destroy.function\n  (#match? @cond.destroy.function \"^(pthread_cond_destroy)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle))"
    },
    {
      "file": "concurrency\\c-16-读写锁初始化同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    pthread_rwlockattr_t attr;\n    \n    // pthread_rwlock_init测试\n    pthread_rwlock_init(&rwlock, &attr);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.rwlock.init\n  function: (identifier) @rwlock.init.function\n  (#match? @rwlock.init.function \"^(pthread_rwlock_init)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle)\n    (identifier)? @rwlock.attributes)"
    },
    {
      "file": "concurrency\\c-17-读写锁读锁同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    \n    pthread_rwlock_init(&rwlock, NULL);\n    \n    // pthread_rwlock_rdlock测试\n    pthread_rwlock_rdlock(&rwlock);\n    \n    // Read-only section\n    // ...\n    \n    pthread_rwlock_unlock(&rwlock);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.rwlock.readlock\n  function: (identifier) @rwlock.readlock.function\n  (#match? @rwlock.readlock.function \"^(pthread_rwlock_rdlock)$\")\n arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle))"
    },
    {
      "file": "concurrency\\c-18-读写锁写锁同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    \n    pthread_rwlock_init(&rwlock, NULL);\n    \n    // pthread_rwlock_wrlock测试\n    pthread_rwlock_wrlock(&rwlock);\n    \n    // Write section\n    // ...\n    \n    pthread_rwlock_unlock(&rwlock);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.rwlock.writelock\n  function: (identifier) @rwlock.writelock.function\n  (#match? @rwlock.writelock.function \"^(pthread_rwlock_wrlock)$\")\n arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle))"
    },
    {
      "file": "concurrency\\c-19-读写锁解锁同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    \n    pthread_rwlock_init(&rwlock, NULL);\n    pthread_rwlock_wrlock(&rwlock);\n    \n    // Write section\n    // ...\n    \n    // pthread_rwlock_unlock测试\n    pthread_rwlock_unlock(&rwlock);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.rwlock.unlock\n  function: (identifier) @rwlock.unlock.function\n  (#match? @rwlock.unlock.function \"^(pthread_rwlock_unlock)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle))"
    },
    {
      "file": "concurrency\\c-2-线程等待并发关系.md",
      "testCase": "#include <pthread.h>\n\nvoid* thread_function(void* arg) {\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    void* result;\n    \n    pthread_create(&thread, NULL, thread_function, NULL);\n    \n    // pthread_join测试\n    pthread_join(thread, &result);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.thread.wait\n  function: (identifier) @thread.wait.function\n  (#match? @thread.wait.function \"^(pthread_join)$\")\n  arguments: (argument_list\n    (identifier) @thread.handle\n    (identifier)? @thread.return.value)"
    },
    {
      "file": "concurrency\\c-20-读写锁销毁同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    \n    pthread_rwlock_init(&rwlock, NULL);\n    pthread_rwlock_wrlock(&rwlock);\n    pthread_rwlock_unlock(&rwlock);\n    \n    // pthread_rwlock_destroy测试\n    pthread_rwlock_destroy(&rwlock);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.rwlock.destroy\n  function: (identifier) @rwlock.destroy.function\n  (#match? @rwlock.destroy.function \"^(pthread_rwlock_destroy)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle))"
    },
    {
      "file": "concurrency\\c-21-信号量初始化同步关系.md",
      "testCase": "#include <semaphore.h>\n\nint main() {\n    sem_t sem;\n    \n    // sem_init测试\n    sem_init(&sem, 0, 1); // 初始化为1，表示可用资源数\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.semaphore.init\n function: (identifier) @semaphore.init.function\n  (#match? @semaphore.init.function \"^(sem_init)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle)\n    (identifier) @semaphore.pshared\n    (identifier) @semaphore.value)"
    },
    {
      "file": "concurrency\\c-22-信号量等待同步关系.md",
      "testCase": "#include <semaphore.h>\n\nint main() {\n    sem_t sem;\n    \n    sem_init(&sem, 0, 1);\n    \n    // sem_wait测试\n    sem_wait(&sem);\n    \n    // Critical section\n    // ...\n    \n    sem_post(&sem);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.semaphore.wait\n  function: (identifier) @semaphore.wait.function\n  (#match? @semaphore.wait.function \"^(sem_wait)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle))"
    },
    {
      "file": "concurrency\\c-23-信号量尝试等待同步关系.md",
      "testCase": "#include <semaphore.h>\n#include <stdio.h>\n\nint main() {\n    sem_t sem;\n    \n    sem_init(&sem, 0, 1);\n    \n    // sem_trywait测试\n    int result = sem_trywait(&sem);\n    if (result == 0) {\n        // Critical section\n        // ...\n        sem_post(&sem);\n    } else {\n        printf(\"Semaphore not available\\n\");\n    }\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.semaphore.trywait\n  function: (identifier) @semaphore.trywait.function\n  (#match? @semaphore.trywait.function \"^(sem_trywait)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle))"
    },
    {
      "file": "concurrency\\c-24-信号量信号同步关系.md",
      "testCase": "#include <semaphore.h>\n\nint main() {\n    sem_t sem;\n    \n    sem_init(&sem, 0, 0);\n    sem_wait(&sem);\n    \n    // Critical section\n    // ...\n    \n    // sem_post测试\n    sem_post(&sem);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.semaphore.post\n  function: (identifier) @semaphore.post.function\n  (#match? @semaphore.post.function \"^(sem_post)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle))"
    },
    {
      "file": "concurrency\\c-25-信号量销毁同步关系.md",
      "testCase": "#include <semaphore.h>\n\nint main() {\n    sem_t sem;\n    \n    sem_init(&sem, 0, 1);\n    sem_wait(&sem);\n    sem_post(&sem);\n    \n    // sem_destroy测试\n    sem_destroy(&sem);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.semaphore.destroy\n  function: (identifier) @semaphore.destroy.function\n  (#match? @semaphore.destroy.function \"^(sem_destroy)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle))"
    },
    {
      "file": "concurrency\\c-26-内存屏障并发关系.md",
      "testCase": "#include <stdatomic.h>\n\nint main() {\n    // atomic_thread_fence测试\n    atomic_thread_fence(memory_order_seq_cst);\n    \n    // __atomic_thread_fence测试\n    __atomic_thread_fence(__ATOMIC_SEQ_CST);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.memory.barrier\n function: (identifier) @memory.barrier.function\n  (#match? @memory.barrier.function \"^(atomic_thread_fence|__atomic_thread_fence)$\")\n  arguments: (argument_list\n    (identifier)? @memory.order)"
    },
    {
      "file": "concurrency\\c-27-编译器屏障并发关系.md",
      "testCase": "int main() {\n    // __sync_synchronize测试\n    __sync_synchronize();\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.compiler.barrier\n  function: (identifier) @compiler.barrier.function\n  (#match? @compiler.barrier.function \"^(__sync_synchronize)$\")\n  arguments: (argument_list)"
    },
    {
      "file": "concurrency\\c-28-线程本地变量声明.md",
      "testCase": "// __thread测试\n__thread int thread_local_var1;\n\n// _Thread_local测试\n_Thread_local int thread_local_var2;\n\n// 线程本地存储的完整声明\n__thread static int counter = 0;\n\nint main() {\n    // 使用线程本地变量\n    thread_local_var1 = 42;\n    thread_local_var2 = 24;\n    counter++;\n    \n    return 0;\n}",
      "queryRule": "(declaration\n  (storage_class_specifier) @thread.local.specifier\n  (#match? @thread.local.specifier \"^(__thread|_Thread_local)$\")\n  type: (primitive_type) @thread.local.type\n  declarator: (identifier) @thread.local.variable) @concurrency.relationship.thread.local"
    },
    {
      "file": "concurrency\\c-3-线程分离并发关系.md",
      "testCase": "#include <pthread.h>\n\nvoid* thread_function(void* arg) {\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    \n    pthread_create(&thread, NULL, thread_function, NULL);\n    \n    // pthread_detach测试\n    pthread_detach(thread);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.thread.detach\n  function: (identifier) @thread.detach.function\n  (#match? @thread.detach.function \"^(pthread_detach)$\")\n  arguments: (argument_list\n    (identifier) @thread.handle)"
    },
    {
      "file": "concurrency\\c-4-线程退出并发关系.md",
      "testCase": "#include <pthread.h>\n\nvoid* thread_function(void* arg) {\n    // pthread_exit测试\n    pthread_exit(NULL);\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    \n    pthread_create(&thread, NULL, thread_function, NULL);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.thread.exit\n  function: (identifier) @thread.exit.function\n  (#match? @thread.exit.function \"^(pthread_exit)$\")\n  arguments: (argument_list\n    (identifier)? @thread.exit.value)"
    },
    {
      "file": "concurrency\\c-5-获取线程ID并发关系.md",
      "testCase": "#include <pthread.h>\n#include <stdio.h>\n\nvoid* thread_function(void* arg) {\n    // pthread_self测试\n    pthread_t tid = pthread_self();\n    printf(\"Thread ID: %lu\\n\", tid);\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    \n    pthread_create(&thread, NULL, thread_function, NULL);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.thread.id\n  function: (identifier) @thread.id.function\n  (#match? @thread.id.function \"^(pthread_self)$\")\n  arguments: (argument_list)"
    },
    {
      "file": "concurrency\\c-6-互斥锁初始化同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    pthread_mutexattr_t attr;\n    \n    // pthread_mutex_init测试\n    pthread_mutex_init(&mutex, &attr);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.mutex.init\n  function: (identifier) @mutex.init.function\n  (#match? @mutex.init.function \"^(pthread_mutex_init)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle)\n    (identifier)? @mutex.attributes)"
    },
    {
      "file": "concurrency\\c-7-互斥锁加锁同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    \n    pthread_mutex_init(&mutex, NULL);\n    \n    // pthread_mutex_lock测试\n    pthread_mutex_lock(&mutex);\n    \n    // Critical section\n    // ...\n    \n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.mutex.lock\n  function: (identifier) @mutex.lock.function\n  (#match? @mutex.lock.function \"^(pthread_mutex_lock)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle))"
    },
    {
      "file": "concurrency\\c-8-互斥锁尝试加锁同步关系.md",
      "testCase": "#include <pthread.h>\n#include <stdio.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    \n    pthread_mutex_init(&mutex, NULL);\n    \n    // pthread_mutex_trylock测试\n    int result = pthread_mutex_trylock(&mutex);\n    if (result == 0) {\n        // Critical section\n        // ...\n        pthread_mutex_unlock(&mutex);\n    } else {\n        printf(\"Mutex is locked by another thread\\n\");\n    }\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.mutex.trylock\n  function: (identifier) @mutex.trylock.function\n  (#match? @mutex.trylock.function \"^(pthread_mutex_trylock)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle))"
    },
    {
      "file": "concurrency\\c-9-互斥锁解锁同步关系.md",
      "testCase": "#include <pthread.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    \n    pthread_mutex_init(&mutex, NULL);\n    pthread_mutex_lock(&mutex);\n    \n    // Critical section\n    // ...\n    \n    // pthread_mutex_unlock测试\n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
      "queryRule": "(call_expression) @concurrency.relationship.mutex.unlock\n  function: (identifier) @mutex.unlock.function\n  (#match? @mutex.unlock.function \"^(pthread_mutex_unlock)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle))"
    },
    {
      "file": "structs\\c-1-结构体定义.md",
      "testCase": "// 结构体定义测试\r\nstruct Point {\r\n    int x;\r\n    int y;\r\n};\r\n\r\nstruct Person {\r\n    char name[50];\r\n    int age;\r\n    float height;\r\n};\r\n\r\n// 嵌套结构体\r\nstruct Rectangle {\r\n    struct Point top_left;\r\n    struct Point bottom_right;\r\n};",
      "queryRule": "(struct_specifier\r\n  name: (type_identifier) @type.name\r\n  body: (field_declaration_list\r\n    (field_declaration\r\n      type: (_) @field.type\r\n      declarator: (field_identifier) @field.name)*)) @definition.struct"
    },
    {
      "file": "structs\\c-10-嵌套结构体查询.md",
      "testCase": "#include <stdio.h>\n\n// 嵌套结构体定义\nstruct Point {\n    int x;\n    int y;\n};\n\nstruct Rectangle {\n    struct Point top_left;\n    struct Point bottom_right;\n};\n\nstruct Circle {\n    struct Point center;\n    int radius;\n};\n\nint main() {\n    struct Rectangle rect;\n    rect.top_left.x = 0;\n    rect.top_left.y = 0;\n    rect.bottom_right.x = 10;\n    rect.bottom_right.y = 10;\n    \n    struct Circle circle;\n    circle.center.x = 5;\n    circle.center.y = 5;\n    circle.radius = 7;\n    \n    return 0;\n}",
      "queryRule": "(struct_specifier\n  body: (field_declaration_list\n    (field_declaration\n      type: (struct_specifier)\n      declarator: (field_identifier) @nested.field.name))) @definition.nested.struct"
    },
    {
      "file": "structs\\c-11-前向声明查询.md",
      "testCase": "// 前向声明测试\nstruct Node;  // 结构体前向声明\nunion Storage;  // 联合体前向声明\nenum State;    // 枚举前向声明\n\n// 完整定义\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nunion Storage {\n    int i;\n    float f;\n    char c;\n};\n\nenum State {\n    INIT,\n    RUNNING,\n    STOPPED\n};\n\nint main() {\n    struct Node* head = NULL;\n    return 0;\n}",
      "queryRule": "(struct_specifier\n  name: (type_identifier) @forward.struct.name) @definition.forward.struct\n\n(union_specifier\n  name: (type_identifier) @forward.union.name) @definition.forward.union\n\n(enum_specifier\n  name: (type_identifier) @forward.enum.name) @definition.forward.enum"
    },
    {
      "file": "structs\\c-2-联合体定义查询.md",
      "testCase": "// 联合体定义测试\r\nunion Data {\r\n    int integer;\r\n    float floating;\r\n    char text[20];\r\n};\r\n\r\nunion Value {\r\n    long number;\r\n    double real;\r\n};",
      "queryRule": "(union_specifier\r\n  name: (type_identifier) @type.name\r\n  body: (field_declaration_list\r\n    (field_declaration\r\n      type: (_) @field.type\r\n      declarator: (field_identifier) @field.name)*)) @definition.union"
    },
    {
      "file": "structs\\c-3-数组声明查询.md",
      "testCase": "// 数组声明测试\nint numbers[10];\nchar buffer[256];\nfloat matrix[5][5];\ndouble values[20];\nchar text[100] = \"Hello\";\nint dynamic_array[];",
      "queryRule": "(declaration\n  type: (_)\n  declarator: (array_declarator\n    declarator: (identifier) @array.name\n    size: (_)? @array.size)) @definition.array"
    },
    {
      "file": "structs\\c-3-枚举定义查询.md",
      "testCase": "// 枚举定义测试\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n};\n\nenum Status {\n    SUCCESS = 0,\n    ERROR = 1,\n    PENDING = 2\n};\n\nenum Direction {\n    NORTH, SOUTH, EAST, WEST\n};",
      "queryRule": "(enum_specifier\n  name: (type_identifier) @type.name\n  body: (enumerator_list\n    (enumerator\n      name: (identifier) @enum.constant)*)) @definition.enum"
    },
    {
      "file": "structs\\c-4-指针声明查询.md",
      "testCase": "// 指针声明测试\nint* ptr;\nchar* string;\nvoid* generic_ptr;\nint** double_ptr;\nconst char* const_str;\nstruct Point* point_ptr;",
      "queryRule": "(declaration\n  type: (_)\n  declarator: (pointer_declarator\n    declarator: (identifier) @pointer.name)) @definition.pointer"
    },
    {
      "file": "structs\\c-4-类型别名查询.md",
      "testCase": "// 类型别名定义测试\ntypedef int Integer;\ntypedef char* String;\ntypedef struct Point Point;\ntypedef enum Color Color;\ntypedef union Data Data;\n\n// 函数指针类型别名\ntypedef int (*Comparator)(int a, int b);",
      "queryRule": "(type_definition\n type: (_)\n  declarator: (type_identifier) @alias.name) @definition.type.alias"
    },
    {
      "file": "structs\\c-5-成员访问查询.md",
      "testCase": "#include <stdio.h>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    struct Point p;\n    p.x = 10;\n    p.y = 20;\n    \n    // 成员访问测试\n    printf(\"X: %d, Y: %d\\n\", p.x, p.y);\n    \n    struct Point* ptr = &p;\n    ptr->x = 30;\n    ptr->y = 40;\n    \n    return 0;\n}",
      "queryRule": "(field_expression\n  argument: (identifier) @object.name\n  field: (field_identifier) @field.name) @definition.member.access"
    },
    {
      "file": "structs\\c-5-数组声明查询.md",
      "testCase": "// 数组声明测试\nint numbers[10];\nchar buffer[256];\nfloat matrix[5][5];\ndouble values[20];\nchar text[100] = \"Hello\";\nint dynamic_array[];",
      "queryRule": "(declaration\n  type: (_)\n  declarator: (array_declarator\n    declarator: (identifier) @array.name\n    size: (_)? @array.size)) @definition.array"
    },
    {
      "file": "structs\\c-6-指针声明查询.md",
      "testCase": "// 指针声明测试\nint* ptr;\nchar* string;\nvoid* generic_ptr;\nint** double_ptr;\nconst char* const_str;\nstruct Point* point_ptr;",
      "queryRule": "(declaration\n  type: (_)\n  declarator: (pointer_declarator\n    declarator: (identifier) @pointer.name)) @definition.pointer"
    },
    {
      "file": "structs\\c-6-指针成员访问查询.md",
      "testCase": "#include <stdio.h>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    struct Point p = {5, 10};\n    struct Point* ptr = &p;\n    \n    // 指针成员访问测试\n    printf(\"X: %d, Y: %d\\n\", ptr->x, ptr->y);\n    \n    // 修改通过指针访问的成员\n    ptr->x = 15;\n    ptr->y = 25;\n    \n    return 0;\n}",
      "queryRule": "(field_expression\n  argument: (pointer_expression\n    argument: (identifier) @pointer.name)\n  field: (field_identifier) @field.name) @definition.pointer.member.access"
    },
    {
      "file": "structs\\c-7-成员访问查询.md",
      "testCase": "#include <stdio.h>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    struct Point p;\n    p.x = 10;\n    p.y = 20;\n    \n    // 成员访问测试\n    printf(\"X: %d, Y: %d\\n\", p.x, p.y);\n    \n    struct Point* ptr = &p;\n    ptr->x = 30;\n    ptr->y = 40;\n    \n    return 0;\n}",
      "queryRule": "(field_expression\n  argument: (identifier) @object.name\n  field: (field_identifier) @field.name) @definition.member.access"
    },
    {
      "file": "structs\\c-7-数组访问查询.md",
      "testCase": "#include <stdio.h>\n\nint main() {\n    int arr[10];\n    int matrix[5][5];\n    \n    // 数组访问测试\n    arr[0] = 1;\n    arr[1] = 2;\n    arr[2] = arr[0] + arr[1];\n    \n    // 二维数组访问\n    matrix[0][0] = 10;\n    matrix[1][2] = 20;\n    \n    // 使用变量作为索引\n    int i = 3;\n    arr[i] = 30;\n    \n    return 0;\n}",
      "queryRule": "(subscript_expression\n  argument: (identifier) @array.name\n  index: (_) @index) @definition.array.access"
    },
    {
      "file": "structs\\c-8-嵌套结构体查询.md",
      "testCase": "#include <stdio.h>\n\n// 嵌套结构体定义\nstruct Point {\n    int x;\n    int y;\n};\n\nstruct Rectangle {\n    struct Point top_left;\n    struct Point bottom_right;\n};\n\nstruct Circle {\n    struct Point center;\n    int radius;\n};\n\nint main() {\n    struct Rectangle rect;\n    rect.top_left.x = 0;\n    rect.top_left.y = 0;\n    rect.bottom_right.x = 10;\n    rect.bottom_right.y = 10;\n    \n    struct Circle circle;\n    circle.center.x = 5;\n    circle.center.y = 5;\n    circle.radius = 7;\n    \n    return 0;\n}",
      "queryRule": "(struct_specifier\n  body: (field_declaration_list\n    (field_declaration\n      type: (struct_specifier)\n      declarator: (field_identifier) @nested.field.name))) @definition.nested.struct"
    },
    {
      "file": "structs\\c-8-指针成员访问查询.md",
      "testCase": "#include <stdio.h>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    struct Point p = {5, 10};\n    struct Point* ptr = &p;\n    \n    // 指针成员访问测试\n    printf(\"X: %d, Y: %d\\n\", ptr->x, ptr->y);\n    \n    // 修改通过指针访问的成员\n    ptr->x = 15;\n    ptr->y = 25;\n    \n    return 0;\n}",
      "queryRule": "(field_expression\n  argument: (pointer_expression\n    argument: (identifier) @pointer.name)\n  field: (field_identifier) @field.name) @definition.pointer.member.access"
    },
    {
      "file": "structs\\c-9-前向声明查询.md",
      "testCase": "// 前向声明测试\nstruct Node;  // 结构体前向声明\nunion Storage;  // 联合体前向声明\nenum State;    // 枚举前向声明\n\n// 完整定义\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nunion Storage {\n    int i;\n    float f;\n    char c;\n};\n\nenum State {\n    INIT,\n    RUNNING,\n    STOPPED\n};\n\nint main() {\n    struct Node* head = NULL;\n    return 0;\n}",
      "queryRule": "(struct_specifier\n  name: (type_identifier) @forward.struct.name) @definition.forward.struct\n\n(union_specifier\n  name: (type_identifier) @forward.union.name) @definition.forward.union\n\n(enum_specifier\n  name: (type_identifier) @forward.enum.name) @definition.forward.enum"
    },
    {
      "file": "structs\\c-9-数组访问查询.md",
      "testCase": "#include <stdio.h>\n\nint main() {\n    int arr[10];\n    int matrix[5][5];\n    \n    // 数组访问测试\n    arr[0] = 1;\n    arr[1] = 2;\n    arr[2] = arr[0] + arr[1];\n    \n    // 二维数组访问\n    matrix[0][0] = 10;\n    matrix[1][2] = 20;\n    \n    // 使用变量作为索引\n    int i = 3;\n    arr[i] = 30;\n    \n    return 0;\n}",
      "queryRule": "(subscript_expression\n  argument: (identifier) @array.name\n  index: (_) @index) @definition.array.access"
    }
  ],
  "apiRequests": {
    "requests": [
      {
        "language": "c",
        "code": "#include <pthread.h>\n#include <windows.h>\n\nvoid* thread_function(void* arg) {\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    pthread_attr_t attr;\n    \n    // pthread_create测试\n    pthread_create(&thread, &attr, thread_function, NULL);\n    \n    // CreateThread测试\n    HANDLE hThread = CreateThread(\n        NULL,                   // Security attributes\n        0,                      // Stack size\n        (LPTHREAD_START_ROUTINE)thread_function,  // Start function\n        NULL,                   // Argument\n        0,                      // Creation flags\n        NULL                    // Thread ID\n    );\n    \n    // _beginthreadex测试\n    HANDLE hThread2 = (HANDLE)_beginthreadex(\n        NULL,                   // Security\n        0,                      // Stack size\n        (LPTHREAD_START_ROUTINE)thread_function,  // Start function\n        NULL,                   // Argument\n        0,                      // Init flag\n        NULL                    // Thread address\n    );\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.thread.creation\n  function: (identifier) @thread.create.function\n  (#match? @thread.create.function \"^(pthread_create|CreateThread|_beginthreadex)$\")\n  arguments: (argument_list\n    (identifier) @thread.handle\n    (identifier) @thread.attributes\n    (identifier) @thread.start.function\n    (identifier) @thread.argument)"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    \n    pthread_mutex_init(&mutex, NULL);\n    pthread_mutex_lock(&mutex);\n    pthread_mutex_unlock(&mutex);\n    \n    // pthread_mutex_destroy测试\n    pthread_mutex_destroy(&mutex);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.mutex.destroy\n  function: (identifier) @mutex.destroy.function\n  (#match? @mutex.destroy.function \"^(pthread_mutex_destroy)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle))"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_cond_t cond;\n    pthread_condattr_t attr;\n    \n    // pthread_cond_init测试\n    pthread_cond_init(&cond, &attr);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.condition.init\n  function: (identifier) @cond.init.function\n  (#match? @cond.init.function \"^(pthread_cond_init)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle)\n    (identifier)? @cond.attributes)"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n#include <time.h>\n\nint main() {\n    pthread_cond_t cond;\n    pthread_mutex_t mutex;\n    \n    pthread_cond_init(&cond, NULL);\n    pthread_mutex_init(&mutex, NULL);\n    \n    pthread_mutex_lock(&mutex);\n    \n    // pthread_cond_wait测试\n    pthread_cond_wait(&cond, &mutex);\n    \n    // pthread_cond_timedwait测试\n    struct timespec timeout;\n    clock_gettime(CLOCK_REALTIME, &timeout);\n    timeout.tv_sec += 5; // 5秒后超时\n    pthread_cond_timedwait(&cond, &mutex, &timeout);\n    \n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.condition.wait\n  function: (identifier) @cond.wait.function\n  (#match? @cond.wait.function \"^(pthread_cond_wait|pthread_cond_timedwait)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle)\n    (pointer_expression argument: (identifier) @mutex.handle))"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_cond_t cond;\n    pthread_mutex_t mutex;\n    \n    pthread_cond_init(&cond, NULL);\n    pthread_mutex_init(&mutex, NULL);\n    \n    pthread_mutex_lock(&mutex);\n    \n    // pthread_cond_signal测试\n    pthread_cond_signal(&cond);\n    \n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.condition.signal\n  function: (identifier) @cond.signal.function\n  (#match? @cond.signal.function \"^(pthread_cond_signal)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle))"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_cond_t cond;\n    pthread_mutex_t mutex;\n    \n    pthread_cond_init(&cond, NULL);\n    pthread_mutex_init(&mutex, NULL);\n    \n    pthread_mutex_lock(&mutex);\n    \n    // pthread_cond_broadcast测试\n    pthread_cond_broadcast(&cond);\n    \n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.condition.broadcast\n  function: (identifier) @cond.broadcast.function\n  (#match? @cond.broadcast.function \"^(pthread_cond_broadcast)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle))"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_cond_t cond;\n    \n    pthread_cond_init(&cond, NULL);\n    \n    // pthread_cond_destroy测试\n    pthread_cond_destroy(&cond);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.condition.destroy\n  function: (identifier) @cond.destroy.function\n  (#match? @cond.destroy.function \"^(pthread_cond_destroy)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @cond.handle))"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    pthread_rwlockattr_t attr;\n    \n    // pthread_rwlock_init测试\n    pthread_rwlock_init(&rwlock, &attr);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.rwlock.init\n  function: (identifier) @rwlock.init.function\n  (#match? @rwlock.init.function \"^(pthread_rwlock_init)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle)\n    (identifier)? @rwlock.attributes)"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    \n    pthread_rwlock_init(&rwlock, NULL);\n    \n    // pthread_rwlock_rdlock测试\n    pthread_rwlock_rdlock(&rwlock);\n    \n    // Read-only section\n    // ...\n    \n    pthread_rwlock_unlock(&rwlock);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.rwlock.readlock\n  function: (identifier) @rwlock.readlock.function\n  (#match? @rwlock.readlock.function \"^(pthread_rwlock_rdlock)$\")\n arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle))"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    \n    pthread_rwlock_init(&rwlock, NULL);\n    \n    // pthread_rwlock_wrlock测试\n    pthread_rwlock_wrlock(&rwlock);\n    \n    // Write section\n    // ...\n    \n    pthread_rwlock_unlock(&rwlock);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.rwlock.writelock\n  function: (identifier) @rwlock.writelock.function\n  (#match? @rwlock.writelock.function \"^(pthread_rwlock_wrlock)$\")\n arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle))"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    \n    pthread_rwlock_init(&rwlock, NULL);\n    pthread_rwlock_wrlock(&rwlock);\n    \n    // Write section\n    // ...\n    \n    // pthread_rwlock_unlock测试\n    pthread_rwlock_unlock(&rwlock);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.rwlock.unlock\n  function: (identifier) @rwlock.unlock.function\n  (#match? @rwlock.unlock.function \"^(pthread_rwlock_unlock)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle))"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nvoid* thread_function(void* arg) {\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    void* result;\n    \n    pthread_create(&thread, NULL, thread_function, NULL);\n    \n    // pthread_join测试\n    pthread_join(thread, &result);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.thread.wait\n  function: (identifier) @thread.wait.function\n  (#match? @thread.wait.function \"^(pthread_join)$\")\n  arguments: (argument_list\n    (identifier) @thread.handle\n    (identifier)? @thread.return.value)"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_rwlock_t rwlock;\n    \n    pthread_rwlock_init(&rwlock, NULL);\n    pthread_rwlock_wrlock(&rwlock);\n    pthread_rwlock_unlock(&rwlock);\n    \n    // pthread_rwlock_destroy测试\n    pthread_rwlock_destroy(&rwlock);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.rwlock.destroy\n  function: (identifier) @rwlock.destroy.function\n  (#match? @rwlock.destroy.function \"^(pthread_rwlock_destroy)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @rwlock.handle))"
      },
      {
        "language": "c",
        "code": "#include <semaphore.h>\n\nint main() {\n    sem_t sem;\n    \n    // sem_init测试\n    sem_init(&sem, 0, 1); // 初始化为1，表示可用资源数\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.semaphore.init\n function: (identifier) @semaphore.init.function\n  (#match? @semaphore.init.function \"^(sem_init)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle)\n    (identifier) @semaphore.pshared\n    (identifier) @semaphore.value)"
      },
      {
        "language": "c",
        "code": "#include <semaphore.h>\n\nint main() {\n    sem_t sem;\n    \n    sem_init(&sem, 0, 1);\n    \n    // sem_wait测试\n    sem_wait(&sem);\n    \n    // Critical section\n    // ...\n    \n    sem_post(&sem);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.semaphore.wait\n  function: (identifier) @semaphore.wait.function\n  (#match? @semaphore.wait.function \"^(sem_wait)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle))"
      },
      {
        "language": "c",
        "code": "#include <semaphore.h>\n#include <stdio.h>\n\nint main() {\n    sem_t sem;\n    \n    sem_init(&sem, 0, 1);\n    \n    // sem_trywait测试\n    int result = sem_trywait(&sem);\n    if (result == 0) {\n        // Critical section\n        // ...\n        sem_post(&sem);\n    } else {\n        printf(\"Semaphore not available\\n\");\n    }\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.semaphore.trywait\n  function: (identifier) @semaphore.trywait.function\n  (#match? @semaphore.trywait.function \"^(sem_trywait)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle))"
      },
      {
        "language": "c",
        "code": "#include <semaphore.h>\n\nint main() {\n    sem_t sem;\n    \n    sem_init(&sem, 0, 0);\n    sem_wait(&sem);\n    \n    // Critical section\n    // ...\n    \n    // sem_post测试\n    sem_post(&sem);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.semaphore.post\n  function: (identifier) @semaphore.post.function\n  (#match? @semaphore.post.function \"^(sem_post)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle))"
      },
      {
        "language": "c",
        "code": "#include <semaphore.h>\n\nint main() {\n    sem_t sem;\n    \n    sem_init(&sem, 0, 1);\n    sem_wait(&sem);\n    sem_post(&sem);\n    \n    // sem_destroy测试\n    sem_destroy(&sem);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.semaphore.destroy\n  function: (identifier) @semaphore.destroy.function\n  (#match? @semaphore.destroy.function \"^(sem_destroy)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @semaphore.handle))"
      },
      {
        "language": "c",
        "code": "#include <stdatomic.h>\n\nint main() {\n    // atomic_thread_fence测试\n    atomic_thread_fence(memory_order_seq_cst);\n    \n    // __atomic_thread_fence测试\n    __atomic_thread_fence(__ATOMIC_SEQ_CST);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.memory.barrier\n function: (identifier) @memory.barrier.function\n  (#match? @memory.barrier.function \"^(atomic_thread_fence|__atomic_thread_fence)$\")\n  arguments: (argument_list\n    (identifier)? @memory.order)"
      },
      {
        "language": "c",
        "code": "int main() {\n    // __sync_synchronize测试\n    __sync_synchronize();\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.compiler.barrier\n  function: (identifier) @compiler.barrier.function\n  (#match? @compiler.barrier.function \"^(__sync_synchronize)$\")\n  arguments: (argument_list)"
      },
      {
        "language": "c",
        "code": "// __thread测试\n__thread int thread_local_var1;\n\n// _Thread_local测试\n_Thread_local int thread_local_var2;\n\n// 线程本地存储的完整声明\n__thread static int counter = 0;\n\nint main() {\n    // 使用线程本地变量\n    thread_local_var1 = 42;\n    thread_local_var2 = 24;\n    counter++;\n    \n    return 0;\n}",
        "query": "(declaration\n  (storage_class_specifier) @thread.local.specifier\n  (#match? @thread.local.specifier \"^(__thread|_Thread_local)$\")\n  type: (primitive_type) @thread.local.type\n  declarator: (identifier) @thread.local.variable) @concurrency.relationship.thread.local"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nvoid* thread_function(void* arg) {\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    \n    pthread_create(&thread, NULL, thread_function, NULL);\n    \n    // pthread_detach测试\n    pthread_detach(thread);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.thread.detach\n  function: (identifier) @thread.detach.function\n  (#match? @thread.detach.function \"^(pthread_detach)$\")\n  arguments: (argument_list\n    (identifier) @thread.handle)"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nvoid* thread_function(void* arg) {\n    // pthread_exit测试\n    pthread_exit(NULL);\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    \n    pthread_create(&thread, NULL, thread_function, NULL);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.thread.exit\n  function: (identifier) @thread.exit.function\n  (#match? @thread.exit.function \"^(pthread_exit)$\")\n  arguments: (argument_list\n    (identifier)? @thread.exit.value)"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n#include <stdio.h>\n\nvoid* thread_function(void* arg) {\n    // pthread_self测试\n    pthread_t tid = pthread_self();\n    printf(\"Thread ID: %lu\\n\", tid);\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    \n    pthread_create(&thread, NULL, thread_function, NULL);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.thread.id\n  function: (identifier) @thread.id.function\n  (#match? @thread.id.function \"^(pthread_self)$\")\n  arguments: (argument_list)"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    pthread_mutexattr_t attr;\n    \n    // pthread_mutex_init测试\n    pthread_mutex_init(&mutex, &attr);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.mutex.init\n  function: (identifier) @mutex.init.function\n  (#match? @mutex.init.function \"^(pthread_mutex_init)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle)\n    (identifier)? @mutex.attributes)"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    \n    pthread_mutex_init(&mutex, NULL);\n    \n    // pthread_mutex_lock测试\n    pthread_mutex_lock(&mutex);\n    \n    // Critical section\n    // ...\n    \n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.mutex.lock\n  function: (identifier) @mutex.lock.function\n  (#match? @mutex.lock.function \"^(pthread_mutex_lock)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle))"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n#include <stdio.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    \n    pthread_mutex_init(&mutex, NULL);\n    \n    // pthread_mutex_trylock测试\n    int result = pthread_mutex_trylock(&mutex);\n    if (result == 0) {\n        // Critical section\n        // ...\n        pthread_mutex_unlock(&mutex);\n    } else {\n        printf(\"Mutex is locked by another thread\\n\");\n    }\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.mutex.trylock\n  function: (identifier) @mutex.trylock.function\n  (#match? @mutex.trylock.function \"^(pthread_mutex_trylock)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle))"
      },
      {
        "language": "c",
        "code": "#include <pthread.h>\n\nint main() {\n    pthread_mutex_t mutex;\n    \n    pthread_mutex_init(&mutex, NULL);\n    pthread_mutex_lock(&mutex);\n    \n    // Critical section\n    // ...\n    \n    // pthread_mutex_unlock测试\n    pthread_mutex_unlock(&mutex);\n    \n    return 0;\n}",
        "query": "(call_expression) @concurrency.relationship.mutex.unlock\n  function: (identifier) @mutex.unlock.function\n  (#match? @mutex.unlock.function \"^(pthread_mutex_unlock)$\")\n  arguments: (argument_list\n    (pointer_expression argument: (identifier) @mutex.handle))"
      },
      {
        "language": "c",
        "code": "// 结构体定义测试\r\nstruct Point {\r\n    int x;\r\n    int y;\r\n};\r\n\r\nstruct Person {\r\n    char name[50];\r\n    int age;\r\n    float height;\r\n};\r\n\r\n// 嵌套结构体\r\nstruct Rectangle {\r\n    struct Point top_left;\r\n    struct Point bottom_right;\r\n};",
        "query": "(struct_specifier\r\n  name: (type_identifier) @type.name\r\n  body: (field_declaration_list\r\n    (field_declaration\r\n      type: (_) @field.type\r\n      declarator: (field_identifier) @field.name)*)) @definition.struct"
      },
      {
        "language": "c",
        "code": "#include <stdio.h>\n\n// 嵌套结构体定义\nstruct Point {\n    int x;\n    int y;\n};\n\nstruct Rectangle {\n    struct Point top_left;\n    struct Point bottom_right;\n};\n\nstruct Circle {\n    struct Point center;\n    int radius;\n};\n\nint main() {\n    struct Rectangle rect;\n    rect.top_left.x = 0;\n    rect.top_left.y = 0;\n    rect.bottom_right.x = 10;\n    rect.bottom_right.y = 10;\n    \n    struct Circle circle;\n    circle.center.x = 5;\n    circle.center.y = 5;\n    circle.radius = 7;\n    \n    return 0;\n}",
        "query": "(struct_specifier\n  body: (field_declaration_list\n    (field_declaration\n      type: (struct_specifier)\n      declarator: (field_identifier) @nested.field.name))) @definition.nested.struct"
      },
      {
        "language": "c",
        "code": "// 前向声明测试\nstruct Node;  // 结构体前向声明\nunion Storage;  // 联合体前向声明\nenum State;    // 枚举前向声明\n\n// 完整定义\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nunion Storage {\n    int i;\n    float f;\n    char c;\n};\n\nenum State {\n    INIT,\n    RUNNING,\n    STOPPED\n};\n\nint main() {\n    struct Node* head = NULL;\n    return 0;\n}",
        "query": "(struct_specifier\n  name: (type_identifier) @forward.struct.name) @definition.forward.struct\n\n(union_specifier\n  name: (type_identifier) @forward.union.name) @definition.forward.union\n\n(enum_specifier\n  name: (type_identifier) @forward.enum.name) @definition.forward.enum"
      },
      {
        "language": "c",
        "code": "// 联合体定义测试\r\nunion Data {\r\n    int integer;\r\n    float floating;\r\n    char text[20];\r\n};\r\n\r\nunion Value {\r\n    long number;\r\n    double real;\r\n};",
        "query": "(union_specifier\r\n  name: (type_identifier) @type.name\r\n  body: (field_declaration_list\r\n    (field_declaration\r\n      type: (_) @field.type\r\n      declarator: (field_identifier) @field.name)*)) @definition.union"
      },
      {
        "language": "c",
        "code": "// 数组声明测试\nint numbers[10];\nchar buffer[256];\nfloat matrix[5][5];\ndouble values[20];\nchar text[100] = \"Hello\";\nint dynamic_array[];",
        "query": "(declaration\n  type: (_)\n  declarator: (array_declarator\n    declarator: (identifier) @array.name\n    size: (_)? @array.size)) @definition.array"
      },
      {
        "language": "c",
        "code": "// 枚举定义测试\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n};\n\nenum Status {\n    SUCCESS = 0,\n    ERROR = 1,\n    PENDING = 2\n};\n\nenum Direction {\n    NORTH, SOUTH, EAST, WEST\n};",
        "query": "(enum_specifier\n  name: (type_identifier) @type.name\n  body: (enumerator_list\n    (enumerator\n      name: (identifier) @enum.constant)*)) @definition.enum"
      },
      {
        "language": "c",
        "code": "// 指针声明测试\nint* ptr;\nchar* string;\nvoid* generic_ptr;\nint** double_ptr;\nconst char* const_str;\nstruct Point* point_ptr;",
        "query": "(declaration\n  type: (_)\n  declarator: (pointer_declarator\n    declarator: (identifier) @pointer.name)) @definition.pointer"
      },
      {
        "language": "c",
        "code": "// 类型别名定义测试\ntypedef int Integer;\ntypedef char* String;\ntypedef struct Point Point;\ntypedef enum Color Color;\ntypedef union Data Data;\n\n// 函数指针类型别名\ntypedef int (*Comparator)(int a, int b);",
        "query": "(type_definition\n type: (_)\n  declarator: (type_identifier) @alias.name) @definition.type.alias"
      },
      {
        "language": "c",
        "code": "#include <stdio.h>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    struct Point p;\n    p.x = 10;\n    p.y = 20;\n    \n    // 成员访问测试\n    printf(\"X: %d, Y: %d\\n\", p.x, p.y);\n    \n    struct Point* ptr = &p;\n    ptr->x = 30;\n    ptr->y = 40;\n    \n    return 0;\n}",
        "query": "(field_expression\n  argument: (identifier) @object.name\n  field: (field_identifier) @field.name) @definition.member.access"
      },
      {
        "language": "c",
        "code": "// 数组声明测试\nint numbers[10];\nchar buffer[256];\nfloat matrix[5][5];\ndouble values[20];\nchar text[100] = \"Hello\";\nint dynamic_array[];",
        "query": "(declaration\n  type: (_)\n  declarator: (array_declarator\n    declarator: (identifier) @array.name\n    size: (_)? @array.size)) @definition.array"
      },
      {
        "language": "c",
        "code": "// 指针声明测试\nint* ptr;\nchar* string;\nvoid* generic_ptr;\nint** double_ptr;\nconst char* const_str;\nstruct Point* point_ptr;",
        "query": "(declaration\n  type: (_)\n  declarator: (pointer_declarator\n    declarator: (identifier) @pointer.name)) @definition.pointer"
      },
      {
        "language": "c",
        "code": "#include <stdio.h>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    struct Point p = {5, 10};\n    struct Point* ptr = &p;\n    \n    // 指针成员访问测试\n    printf(\"X: %d, Y: %d\\n\", ptr->x, ptr->y);\n    \n    // 修改通过指针访问的成员\n    ptr->x = 15;\n    ptr->y = 25;\n    \n    return 0;\n}",
        "query": "(field_expression\n  argument: (pointer_expression\n    argument: (identifier) @pointer.name)\n  field: (field_identifier) @field.name) @definition.pointer.member.access"
      },
      {
        "language": "c",
        "code": "#include <stdio.h>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    struct Point p;\n    p.x = 10;\n    p.y = 20;\n    \n    // 成员访问测试\n    printf(\"X: %d, Y: %d\\n\", p.x, p.y);\n    \n    struct Point* ptr = &p;\n    ptr->x = 30;\n    ptr->y = 40;\n    \n    return 0;\n}",
        "query": "(field_expression\n  argument: (identifier) @object.name\n  field: (field_identifier) @field.name) @definition.member.access"
      },
      {
        "language": "c",
        "code": "#include <stdio.h>\n\nint main() {\n    int arr[10];\n    int matrix[5][5];\n    \n    // 数组访问测试\n    arr[0] = 1;\n    arr[1] = 2;\n    arr[2] = arr[0] + arr[1];\n    \n    // 二维数组访问\n    matrix[0][0] = 10;\n    matrix[1][2] = 20;\n    \n    // 使用变量作为索引\n    int i = 3;\n    arr[i] = 30;\n    \n    return 0;\n}",
        "query": "(subscript_expression\n  argument: (identifier) @array.name\n  index: (_) @index) @definition.array.access"
      },
      {
        "language": "c",
        "code": "#include <stdio.h>\n\n// 嵌套结构体定义\nstruct Point {\n    int x;\n    int y;\n};\n\nstruct Rectangle {\n    struct Point top_left;\n    struct Point bottom_right;\n};\n\nstruct Circle {\n    struct Point center;\n    int radius;\n};\n\nint main() {\n    struct Rectangle rect;\n    rect.top_left.x = 0;\n    rect.top_left.y = 0;\n    rect.bottom_right.x = 10;\n    rect.bottom_right.y = 10;\n    \n    struct Circle circle;\n    circle.center.x = 5;\n    circle.center.y = 5;\n    circle.radius = 7;\n    \n    return 0;\n}",
        "query": "(struct_specifier\n  body: (field_declaration_list\n    (field_declaration\n      type: (struct_specifier)\n      declarator: (field_identifier) @nested.field.name))) @definition.nested.struct"
      },
      {
        "language": "c",
        "code": "#include <stdio.h>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    struct Point p = {5, 10};\n    struct Point* ptr = &p;\n    \n    // 指针成员访问测试\n    printf(\"X: %d, Y: %d\\n\", ptr->x, ptr->y);\n    \n    // 修改通过指针访问的成员\n    ptr->x = 15;\n    ptr->y = 25;\n    \n    return 0;\n}",
        "query": "(field_expression\n  argument: (pointer_expression\n    argument: (identifier) @pointer.name)\n  field: (field_identifier) @field.name) @definition.pointer.member.access"
      },
      {
        "language": "c",
        "code": "// 前向声明测试\nstruct Node;  // 结构体前向声明\nunion Storage;  // 联合体前向声明\nenum State;    // 枚举前向声明\n\n// 完整定义\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nunion Storage {\n    int i;\n    float f;\n    char c;\n};\n\nenum State {\n    INIT,\n    RUNNING,\n    STOPPED\n};\n\nint main() {\n    struct Node* head = NULL;\n    return 0;\n}",
        "query": "(struct_specifier\n  name: (type_identifier) @forward.struct.name) @definition.forward.struct\n\n(union_specifier\n  name: (type_identifier) @forward.union.name) @definition.forward.union\n\n(enum_specifier\n  name: (type_identifier) @forward.enum.name) @definition.forward.enum"
      },
      {
        "language": "c",
        "code": "#include <stdio.h>\n\nint main() {\n    int arr[10];\n    int matrix[5][5];\n    \n    // 数组访问测试\n    arr[0] = 1;\n    arr[1] = 2;\n    arr[2] = arr[0] + arr[1];\n    \n    // 二维数组访问\n    matrix[0][0] = 10;\n    matrix[1][2] = 20;\n    \n    // 使用变量作为索引\n    int i = 3;\n    arr[i] = 30;\n    \n    return 0;\n}",
        "query": "(subscript_expression\n  argument: (identifier) @array.name\n  index: (_) @index) @definition.array.access"
      }
    ]
  }
}